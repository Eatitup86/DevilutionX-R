// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: command.proto
// Protobuf C++ Version: 5.29.3

#ifndef command_2eproto_2epb_2eh
#define command_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_command_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_command_2eproto {
  static const ::uint32_t offsets[];
};
namespace dapi {
namespace commands {
class AttackMonster;
struct AttackMonsterDefaultTypeInternal;
extern AttackMonsterDefaultTypeInternal _AttackMonster_default_instance_;
class AttackXY;
struct AttackXYDefaultTypeInternal;
extern AttackXYDefaultTypeInternal _AttackXY_default_instance_;
class BuyItem;
struct BuyItemDefaultTypeInternal;
extern BuyItemDefaultTypeInternal _BuyItem_default_instance_;
class CancelQText;
struct CancelQTextDefaultTypeInternal;
extern CancelQTextDefaultTypeInternal _CancelQText_default_instance_;
class CastMonster;
struct CastMonsterDefaultTypeInternal;
extern CastMonsterDefaultTypeInternal _CastMonster_default_instance_;
class CastXY;
struct CastXYDefaultTypeInternal;
extern CastXYDefaultTypeInternal _CastXY_default_instance_;
class ClearCursor;
struct ClearCursorDefaultTypeInternal;
extern ClearCursorDefaultTypeInternal _ClearCursor_default_instance_;
class Command;
struct CommandDefaultTypeInternal;
extern CommandDefaultTypeInternal _Command_default_instance_;
class DisarmTrap;
struct DisarmTrapDefaultTypeInternal;
extern DisarmTrapDefaultTypeInternal _DisarmTrap_default_instance_;
class DropCursorItem;
struct DropCursorItemDefaultTypeInternal;
extern DropCursorItemDefaultTypeInternal _DropCursorItem_default_instance_;
class GetItem;
struct GetItemDefaultTypeInternal;
extern GetItemDefaultTypeInternal _GetItem_default_instance_;
class IdentifyItem;
struct IdentifyItemDefaultTypeInternal;
extern IdentifyItemDefaultTypeInternal _IdentifyItem_default_instance_;
class IdentifyStoreItem;
struct IdentifyStoreItemDefaultTypeInternal;
extern IdentifyStoreItemDefaultTypeInternal _IdentifyStoreItem_default_instance_;
class IncreaseStat;
struct IncreaseStatDefaultTypeInternal;
extern IncreaseStatDefaultTypeInternal _IncreaseStat_default_instance_;
class Move;
struct MoveDefaultTypeInternal;
extern MoveDefaultTypeInternal _Move_default_instance_;
class OperateObject;
struct OperateObjectDefaultTypeInternal;
extern OperateObjectDefaultTypeInternal _OperateObject_default_instance_;
class PutCursorItem;
struct PutCursorItemDefaultTypeInternal;
extern PutCursorItemDefaultTypeInternal _PutCursorItem_default_instance_;
class PutInCursor;
struct PutInCursorDefaultTypeInternal;
extern PutInCursorDefaultTypeInternal _PutInCursor_default_instance_;
class Quit;
struct QuitDefaultTypeInternal;
extern QuitDefaultTypeInternal _Quit_default_instance_;
class RechargeItem;
struct RechargeItemDefaultTypeInternal;
extern RechargeItemDefaultTypeInternal _RechargeItem_default_instance_;
class RepairItem;
struct RepairItemDefaultTypeInternal;
extern RepairItemDefaultTypeInternal _RepairItem_default_instance_;
class SaveGame;
struct SaveGameDefaultTypeInternal;
extern SaveGameDefaultTypeInternal _SaveGame_default_instance_;
class SelectStoreOption;
struct SelectStoreOptionDefaultTypeInternal;
extern SelectStoreOptionDefaultTypeInternal _SelectStoreOption_default_instance_;
class SellItem;
struct SellItemDefaultTypeInternal;
extern SellItemDefaultTypeInternal _SellItem_default_instance_;
class SetFPS;
struct SetFPSDefaultTypeInternal;
extern SetFPSDefaultTypeInternal _SetFPS_default_instance_;
class SetSpell;
struct SetSpellDefaultTypeInternal;
extern SetSpellDefaultTypeInternal _SetSpell_default_instance_;
class SkillRecharge;
struct SkillRechargeDefaultTypeInternal;
extern SkillRechargeDefaultTypeInternal _SkillRecharge_default_instance_;
class SkillRepair;
struct SkillRepairDefaultTypeInternal;
extern SkillRepairDefaultTypeInternal _SkillRepair_default_instance_;
class Talk;
struct TalkDefaultTypeInternal;
extern TalkDefaultTypeInternal _Talk_default_instance_;
class ToggleCharacterSheet;
struct ToggleCharacterSheetDefaultTypeInternal;
extern ToggleCharacterSheetDefaultTypeInternal _ToggleCharacterSheet_default_instance_;
class ToggleInventory;
struct ToggleInventoryDefaultTypeInternal;
extern ToggleInventoryDefaultTypeInternal _ToggleInventory_default_instance_;
class ToggleMenu;
struct ToggleMenuDefaultTypeInternal;
extern ToggleMenuDefaultTypeInternal _ToggleMenu_default_instance_;
class UseBeltItem;
struct UseBeltItemDefaultTypeInternal;
extern UseBeltItemDefaultTypeInternal _UseBeltItem_default_instance_;
class UseItem;
struct UseItemDefaultTypeInternal;
extern UseItemDefaultTypeInternal _UseItem_default_instance_;
}  // namespace commands
}  // namespace dapi
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace dapi {
namespace commands {

// ===================================================================


// -------------------------------------------------------------------

class UseItem final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:dapi.commands.UseItem) */ {
 public:
  inline UseItem() : UseItem(nullptr) {}
  ~UseItem() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UseItem* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UseItem));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UseItem(
      ::google::protobuf::internal::ConstantInitialized);

  inline UseItem(const UseItem& from) : UseItem(nullptr, from) {}
  inline UseItem(UseItem&& from) noexcept
      : UseItem(nullptr, std::move(from)) {}
  inline UseItem& operator=(const UseItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline UseItem& operator=(UseItem&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const UseItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const UseItem* internal_default_instance() {
    return reinterpret_cast<const UseItem*>(
        &_UseItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 23;
  friend void swap(UseItem& a, UseItem& b) { a.Swap(&b); }
  inline void Swap(UseItem* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UseItem* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UseItem* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<UseItem>(arena);
  }
  void CopyFrom(const UseItem& from);
  void MergeFrom(const UseItem& from) { UseItem::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UseItem* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dapi.commands.UseItem"; }

 protected:
  explicit UseItem(::google::protobuf::Arena* arena);
  UseItem(::google::protobuf::Arena* arena, const UseItem& from);
  UseItem(::google::protobuf::Arena* arena, UseItem&& from) noexcept
      : UseItem(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataLite<22> _class_data_;

 public:
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIDFieldNumber = 1,
  };
  // uint32 ID = 1;
  void clear_id() ;
  ::uint32_t id() const;
  void set_id(::uint32_t value);

  private:
  ::uint32_t _internal_id() const;
  void _internal_set_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dapi.commands.UseItem)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const UseItem& from_msg);
    ::uint32_t id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class UseBeltItem final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:dapi.commands.UseBeltItem) */ {
 public:
  inline UseBeltItem() : UseBeltItem(nullptr) {}
  ~UseBeltItem() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UseBeltItem* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UseBeltItem));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UseBeltItem(
      ::google::protobuf::internal::ConstantInitialized);

  inline UseBeltItem(const UseBeltItem& from) : UseBeltItem(nullptr, from) {}
  inline UseBeltItem(UseBeltItem&& from) noexcept
      : UseBeltItem(nullptr, std::move(from)) {}
  inline UseBeltItem& operator=(const UseBeltItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline UseBeltItem& operator=(UseBeltItem&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const UseBeltItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const UseBeltItem* internal_default_instance() {
    return reinterpret_cast<const UseBeltItem*>(
        &_UseBeltItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(UseBeltItem& a, UseBeltItem& b) { a.Swap(&b); }
  inline void Swap(UseBeltItem* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UseBeltItem* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UseBeltItem* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<UseBeltItem>(arena);
  }
  void CopyFrom(const UseBeltItem& from);
  void MergeFrom(const UseBeltItem& from) { UseBeltItem::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UseBeltItem* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dapi.commands.UseBeltItem"; }

 protected:
  explicit UseBeltItem(::google::protobuf::Arena* arena);
  UseBeltItem(::google::protobuf::Arena* arena, const UseBeltItem& from);
  UseBeltItem(::google::protobuf::Arena* arena, UseBeltItem&& from) noexcept
      : UseBeltItem(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataLite<26> _class_data_;

 public:
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSlotFieldNumber = 1,
  };
  // uint32 slot = 1;
  void clear_slot() ;
  ::uint32_t slot() const;
  void set_slot(::uint32_t value);

  private:
  ::uint32_t _internal_slot() const;
  void _internal_set_slot(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dapi.commands.UseBeltItem)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const UseBeltItem& from_msg);
    ::uint32_t slot_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class ToggleMenu final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:dapi.commands.ToggleMenu) */ {
 public:
  inline ToggleMenu() : ToggleMenu(nullptr) {}
  ~ToggleMenu() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ToggleMenu* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ToggleMenu));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ToggleMenu(
      ::google::protobuf::internal::ConstantInitialized);

  inline ToggleMenu(const ToggleMenu& from) : ToggleMenu(nullptr, from) {}
  inline ToggleMenu(ToggleMenu&& from) noexcept
      : ToggleMenu(nullptr, std::move(from)) {}
  inline ToggleMenu& operator=(const ToggleMenu& from) {
    CopyFrom(from);
    return *this;
  }
  inline ToggleMenu& operator=(ToggleMenu&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ToggleMenu& default_instance() {
    return *internal_default_instance();
  }
  static inline const ToggleMenu* internal_default_instance() {
    return reinterpret_cast<const ToggleMenu*>(
        &_ToggleMenu_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 28;
  friend void swap(ToggleMenu& a, ToggleMenu& b) { a.Swap(&b); }
  inline void Swap(ToggleMenu* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ToggleMenu* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ToggleMenu* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<ToggleMenu>(arena);
  }
  void CopyFrom(const ToggleMenu& from);
  void MergeFrom(const ToggleMenu& from) { ToggleMenu::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ToggleMenu* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dapi.commands.ToggleMenu"; }

 protected:
  explicit ToggleMenu(::google::protobuf::Arena* arena);
  ToggleMenu(::google::protobuf::Arena* arena, const ToggleMenu& from);
  ToggleMenu(::google::protobuf::Arena* arena, ToggleMenu&& from) noexcept
      : ToggleMenu(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataLite<25> _class_data_;

 public:
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:dapi.commands.ToggleMenu)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ToggleMenu& from_msg);
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class ToggleInventory final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:dapi.commands.ToggleInventory) */ {
 public:
  inline ToggleInventory() : ToggleInventory(nullptr) {}
  ~ToggleInventory() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ToggleInventory* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ToggleInventory));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ToggleInventory(
      ::google::protobuf::internal::ConstantInitialized);

  inline ToggleInventory(const ToggleInventory& from) : ToggleInventory(nullptr, from) {}
  inline ToggleInventory(ToggleInventory&& from) noexcept
      : ToggleInventory(nullptr, std::move(from)) {}
  inline ToggleInventory& operator=(const ToggleInventory& from) {
    CopyFrom(from);
    return *this;
  }
  inline ToggleInventory& operator=(ToggleInventory&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ToggleInventory& default_instance() {
    return *internal_default_instance();
  }
  static inline const ToggleInventory* internal_default_instance() {
    return reinterpret_cast<const ToggleInventory*>(
        &_ToggleInventory_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(ToggleInventory& a, ToggleInventory& b) { a.Swap(&b); }
  inline void Swap(ToggleInventory* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ToggleInventory* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ToggleInventory* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<ToggleInventory>(arena);
  }
  void CopyFrom(const ToggleInventory& from);
  void MergeFrom(const ToggleInventory& from) { ToggleInventory::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ToggleInventory* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dapi.commands.ToggleInventory"; }

 protected:
  explicit ToggleInventory(::google::protobuf::Arena* arena);
  ToggleInventory(::google::protobuf::Arena* arena, const ToggleInventory& from);
  ToggleInventory(::google::protobuf::Arena* arena, ToggleInventory&& from) noexcept
      : ToggleInventory(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataLite<30> _class_data_;

 public:
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:dapi.commands.ToggleInventory)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ToggleInventory& from_msg);
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class ToggleCharacterSheet final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:dapi.commands.ToggleCharacterSheet) */ {
 public:
  inline ToggleCharacterSheet() : ToggleCharacterSheet(nullptr) {}
  ~ToggleCharacterSheet() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ToggleCharacterSheet* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ToggleCharacterSheet));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ToggleCharacterSheet(
      ::google::protobuf::internal::ConstantInitialized);

  inline ToggleCharacterSheet(const ToggleCharacterSheet& from) : ToggleCharacterSheet(nullptr, from) {}
  inline ToggleCharacterSheet(ToggleCharacterSheet&& from) noexcept
      : ToggleCharacterSheet(nullptr, std::move(from)) {}
  inline ToggleCharacterSheet& operator=(const ToggleCharacterSheet& from) {
    CopyFrom(from);
    return *this;
  }
  inline ToggleCharacterSheet& operator=(ToggleCharacterSheet&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ToggleCharacterSheet& default_instance() {
    return *internal_default_instance();
  }
  static inline const ToggleCharacterSheet* internal_default_instance() {
    return reinterpret_cast<const ToggleCharacterSheet*>(
        &_ToggleCharacterSheet_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(ToggleCharacterSheet& a, ToggleCharacterSheet& b) { a.Swap(&b); }
  inline void Swap(ToggleCharacterSheet* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ToggleCharacterSheet* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ToggleCharacterSheet* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<ToggleCharacterSheet>(arena);
  }
  void CopyFrom(const ToggleCharacterSheet& from);
  void MergeFrom(const ToggleCharacterSheet& from) { ToggleCharacterSheet::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ToggleCharacterSheet* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dapi.commands.ToggleCharacterSheet"; }

 protected:
  explicit ToggleCharacterSheet(::google::protobuf::Arena* arena);
  ToggleCharacterSheet(::google::protobuf::Arena* arena, const ToggleCharacterSheet& from);
  ToggleCharacterSheet(::google::protobuf::Arena* arena, ToggleCharacterSheet&& from) noexcept
      : ToggleCharacterSheet(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataLite<35> _class_data_;

 public:
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:dapi.commands.ToggleCharacterSheet)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ToggleCharacterSheet& from_msg);
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class Talk final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:dapi.commands.Talk) */ {
 public:
  inline Talk() : Talk(nullptr) {}
  ~Talk() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Talk* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Talk));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Talk(
      ::google::protobuf::internal::ConstantInitialized);

  inline Talk(const Talk& from) : Talk(nullptr, from) {}
  inline Talk(Talk&& from) noexcept
      : Talk(nullptr, std::move(from)) {}
  inline Talk& operator=(const Talk& from) {
    CopyFrom(from);
    return *this;
  }
  inline Talk& operator=(Talk&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Talk& default_instance() {
    return *internal_default_instance();
  }
  static inline const Talk* internal_default_instance() {
    return reinterpret_cast<const Talk*>(
        &_Talk_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(Talk& a, Talk& b) { a.Swap(&b); }
  inline void Swap(Talk* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Talk* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Talk* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<Talk>(arena);
  }
  void CopyFrom(const Talk& from);
  void MergeFrom(const Talk& from) { Talk::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Talk* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dapi.commands.Talk"; }

 protected:
  explicit Talk(::google::protobuf::Arena* arena);
  Talk(::google::protobuf::Arena* arena, const Talk& from);
  Talk(::google::protobuf::Arena* arena, Talk&& from) noexcept
      : Talk(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataLite<19> _class_data_;

 public:
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTargetXFieldNumber = 1,
    kTargetYFieldNumber = 2,
  };
  // uint32 targetX = 1;
  void clear_targetx() ;
  ::uint32_t targetx() const;
  void set_targetx(::uint32_t value);

  private:
  ::uint32_t _internal_targetx() const;
  void _internal_set_targetx(::uint32_t value);

  public:
  // uint32 targetY = 2;
  void clear_targety() ;
  ::uint32_t targety() const;
  void set_targety(::uint32_t value);

  private:
  ::uint32_t _internal_targety() const;
  void _internal_set_targety(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dapi.commands.Talk)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Talk& from_msg);
    ::uint32_t targetx_;
    ::uint32_t targety_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class SkillRepair final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:dapi.commands.SkillRepair) */ {
 public:
  inline SkillRepair() : SkillRepair(nullptr) {}
  ~SkillRepair() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SkillRepair* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SkillRepair));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SkillRepair(
      ::google::protobuf::internal::ConstantInitialized);

  inline SkillRepair(const SkillRepair& from) : SkillRepair(nullptr, from) {}
  inline SkillRepair(SkillRepair&& from) noexcept
      : SkillRepair(nullptr, std::move(from)) {}
  inline SkillRepair& operator=(const SkillRepair& from) {
    CopyFrom(from);
    return *this;
  }
  inline SkillRepair& operator=(SkillRepair&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SkillRepair& default_instance() {
    return *internal_default_instance();
  }
  static inline const SkillRepair* internal_default_instance() {
    return reinterpret_cast<const SkillRepair*>(
        &_SkillRepair_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 26;
  friend void swap(SkillRepair& a, SkillRepair& b) { a.Swap(&b); }
  inline void Swap(SkillRepair* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SkillRepair* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SkillRepair* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<SkillRepair>(arena);
  }
  void CopyFrom(const SkillRepair& from);
  void MergeFrom(const SkillRepair& from) { SkillRepair::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SkillRepair* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dapi.commands.SkillRepair"; }

 protected:
  explicit SkillRepair(::google::protobuf::Arena* arena);
  SkillRepair(::google::protobuf::Arena* arena, const SkillRepair& from);
  SkillRepair(::google::protobuf::Arena* arena, SkillRepair&& from) noexcept
      : SkillRepair(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataLite<26> _class_data_;

 public:
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIDFieldNumber = 1,
  };
  // uint32 ID = 1;
  void clear_id() ;
  ::uint32_t id() const;
  void set_id(::uint32_t value);

  private:
  ::uint32_t _internal_id() const;
  void _internal_set_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dapi.commands.SkillRepair)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SkillRepair& from_msg);
    ::uint32_t id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class SkillRecharge final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:dapi.commands.SkillRecharge) */ {
 public:
  inline SkillRecharge() : SkillRecharge(nullptr) {}
  ~SkillRecharge() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SkillRecharge* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SkillRecharge));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SkillRecharge(
      ::google::protobuf::internal::ConstantInitialized);

  inline SkillRecharge(const SkillRecharge& from) : SkillRecharge(nullptr, from) {}
  inline SkillRecharge(SkillRecharge&& from) noexcept
      : SkillRecharge(nullptr, std::move(from)) {}
  inline SkillRecharge& operator=(const SkillRecharge& from) {
    CopyFrom(from);
    return *this;
  }
  inline SkillRecharge& operator=(SkillRecharge&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SkillRecharge& default_instance() {
    return *internal_default_instance();
  }
  static inline const SkillRecharge* internal_default_instance() {
    return reinterpret_cast<const SkillRecharge*>(
        &_SkillRecharge_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 27;
  friend void swap(SkillRecharge& a, SkillRecharge& b) { a.Swap(&b); }
  inline void Swap(SkillRecharge* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SkillRecharge* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SkillRecharge* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<SkillRecharge>(arena);
  }
  void CopyFrom(const SkillRecharge& from);
  void MergeFrom(const SkillRecharge& from) { SkillRecharge::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SkillRecharge* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dapi.commands.SkillRecharge"; }

 protected:
  explicit SkillRecharge(::google::protobuf::Arena* arena);
  SkillRecharge(::google::protobuf::Arena* arena, const SkillRecharge& from);
  SkillRecharge(::google::protobuf::Arena* arena, SkillRecharge&& from) noexcept
      : SkillRecharge(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataLite<28> _class_data_;

 public:
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIDFieldNumber = 1,
  };
  // uint32 ID = 1;
  void clear_id() ;
  ::uint32_t id() const;
  void set_id(::uint32_t value);

  private:
  ::uint32_t _internal_id() const;
  void _internal_set_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dapi.commands.SkillRecharge)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SkillRecharge& from_msg);
    ::uint32_t id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class SetSpell final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:dapi.commands.SetSpell) */ {
 public:
  inline SetSpell() : SetSpell(nullptr) {}
  ~SetSpell() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SetSpell* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SetSpell));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SetSpell(
      ::google::protobuf::internal::ConstantInitialized);

  inline SetSpell(const SetSpell& from) : SetSpell(nullptr, from) {}
  inline SetSpell(SetSpell&& from) noexcept
      : SetSpell(nullptr, std::move(from)) {}
  inline SetSpell& operator=(const SetSpell& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetSpell& operator=(SetSpell&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SetSpell& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetSpell* internal_default_instance() {
    return reinterpret_cast<const SetSpell*>(
        &_SetSpell_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(SetSpell& a, SetSpell& b) { a.Swap(&b); }
  inline void Swap(SetSpell* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetSpell* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetSpell* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<SetSpell>(arena);
  }
  void CopyFrom(const SetSpell& from);
  void MergeFrom(const SetSpell& from) { SetSpell::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SetSpell* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dapi.commands.SetSpell"; }

 protected:
  explicit SetSpell(::google::protobuf::Arena* arena);
  SetSpell(::google::protobuf::Arena* arena, const SetSpell& from);
  SetSpell(::google::protobuf::Arena* arena, SetSpell&& from) noexcept
      : SetSpell(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataLite<23> _class_data_;

 public:
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSpellIDFieldNumber = 1,
    kSpellTypeFieldNumber = 2,
  };
  // sint32 spellID = 1;
  void clear_spellid() ;
  ::int32_t spellid() const;
  void set_spellid(::int32_t value);

  private:
  ::int32_t _internal_spellid() const;
  void _internal_set_spellid(::int32_t value);

  public:
  // sint32 spellType = 2;
  void clear_spelltype() ;
  ::int32_t spelltype() const;
  void set_spelltype(::int32_t value);

  private:
  ::int32_t _internal_spelltype() const;
  void _internal_set_spelltype(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dapi.commands.SetSpell)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SetSpell& from_msg);
    ::int32_t spellid_;
    ::int32_t spelltype_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class SetFPS final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:dapi.commands.SetFPS) */ {
 public:
  inline SetFPS() : SetFPS(nullptr) {}
  ~SetFPS() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SetFPS* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SetFPS));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SetFPS(
      ::google::protobuf::internal::ConstantInitialized);

  inline SetFPS(const SetFPS& from) : SetFPS(nullptr, from) {}
  inline SetFPS(SetFPS&& from) noexcept
      : SetFPS(nullptr, std::move(from)) {}
  inline SetFPS& operator=(const SetFPS& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetFPS& operator=(SetFPS&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SetFPS& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetFPS* internal_default_instance() {
    return reinterpret_cast<const SetFPS*>(
        &_SetFPS_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(SetFPS& a, SetFPS& b) { a.Swap(&b); }
  inline void Swap(SetFPS* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetFPS* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetFPS* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<SetFPS>(arena);
  }
  void CopyFrom(const SetFPS& from);
  void MergeFrom(const SetFPS& from) { SetFPS::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SetFPS* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dapi.commands.SetFPS"; }

 protected:
  explicit SetFPS(::google::protobuf::Arena* arena);
  SetFPS(::google::protobuf::Arena* arena, const SetFPS& from);
  SetFPS(::google::protobuf::Arena* arena, SetFPS&& from) noexcept
      : SetFPS(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataLite<21> _class_data_;

 public:
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFPSFieldNumber = 1,
  };
  // uint32 FPS = 1;
  void clear_fps() ;
  ::uint32_t fps() const;
  void set_fps(::uint32_t value);

  private:
  ::uint32_t _internal_fps() const;
  void _internal_set_fps(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dapi.commands.SetFPS)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SetFPS& from_msg);
    ::uint32_t fps_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class SellItem final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:dapi.commands.SellItem) */ {
 public:
  inline SellItem() : SellItem(nullptr) {}
  ~SellItem() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SellItem* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SellItem));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SellItem(
      ::google::protobuf::internal::ConstantInitialized);

  inline SellItem(const SellItem& from) : SellItem(nullptr, from) {}
  inline SellItem(SellItem&& from) noexcept
      : SellItem(nullptr, std::move(from)) {}
  inline SellItem& operator=(const SellItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline SellItem& operator=(SellItem&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SellItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const SellItem* internal_default_instance() {
    return reinterpret_cast<const SellItem*>(
        &_SellItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(SellItem& a, SellItem& b) { a.Swap(&b); }
  inline void Swap(SellItem* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SellItem* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SellItem* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<SellItem>(arena);
  }
  void CopyFrom(const SellItem& from);
  void MergeFrom(const SellItem& from) { SellItem::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SellItem* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dapi.commands.SellItem"; }

 protected:
  explicit SellItem(::google::protobuf::Arena* arena);
  SellItem(::google::protobuf::Arena* arena, const SellItem& from);
  SellItem(::google::protobuf::Arena* arena, SellItem&& from) noexcept
      : SellItem(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataLite<23> _class_data_;

 public:
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIDFieldNumber = 1,
  };
  // uint32 ID = 1;
  void clear_id() ;
  ::uint32_t id() const;
  void set_id(::uint32_t value);

  private:
  ::uint32_t _internal_id() const;
  void _internal_set_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dapi.commands.SellItem)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SellItem& from_msg);
    ::uint32_t id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class SelectStoreOption final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:dapi.commands.SelectStoreOption) */ {
 public:
  inline SelectStoreOption() : SelectStoreOption(nullptr) {}
  ~SelectStoreOption() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SelectStoreOption* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SelectStoreOption));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SelectStoreOption(
      ::google::protobuf::internal::ConstantInitialized);

  inline SelectStoreOption(const SelectStoreOption& from) : SelectStoreOption(nullptr, from) {}
  inline SelectStoreOption(SelectStoreOption&& from) noexcept
      : SelectStoreOption(nullptr, std::move(from)) {}
  inline SelectStoreOption& operator=(const SelectStoreOption& from) {
    CopyFrom(from);
    return *this;
  }
  inline SelectStoreOption& operator=(SelectStoreOption&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SelectStoreOption& default_instance() {
    return *internal_default_instance();
  }
  static inline const SelectStoreOption* internal_default_instance() {
    return reinterpret_cast<const SelectStoreOption*>(
        &_SelectStoreOption_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(SelectStoreOption& a, SelectStoreOption& b) { a.Swap(&b); }
  inline void Swap(SelectStoreOption* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SelectStoreOption* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SelectStoreOption* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<SelectStoreOption>(arena);
  }
  void CopyFrom(const SelectStoreOption& from);
  void MergeFrom(const SelectStoreOption& from) { SelectStoreOption::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SelectStoreOption* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dapi.commands.SelectStoreOption"; }

 protected:
  explicit SelectStoreOption(::google::protobuf::Arena* arena);
  SelectStoreOption(::google::protobuf::Arena* arena, const SelectStoreOption& from);
  SelectStoreOption(::google::protobuf::Arena* arena, SelectStoreOption&& from) noexcept
      : SelectStoreOption(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataLite<32> _class_data_;

 public:
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOptionFieldNumber = 1,
  };
  // uint32 option = 1;
  void clear_option() ;
  ::uint32_t option() const;
  void set_option(::uint32_t value);

  private:
  ::uint32_t _internal_option() const;
  void _internal_set_option(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dapi.commands.SelectStoreOption)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SelectStoreOption& from_msg);
    ::uint32_t option_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class SaveGame final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:dapi.commands.SaveGame) */ {
 public:
  inline SaveGame() : SaveGame(nullptr) {}
  ~SaveGame() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SaveGame* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SaveGame));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SaveGame(
      ::google::protobuf::internal::ConstantInitialized);

  inline SaveGame(const SaveGame& from) : SaveGame(nullptr, from) {}
  inline SaveGame(SaveGame&& from) noexcept
      : SaveGame(nullptr, std::move(from)) {}
  inline SaveGame& operator=(const SaveGame& from) {
    CopyFrom(from);
    return *this;
  }
  inline SaveGame& operator=(SaveGame&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SaveGame& default_instance() {
    return *internal_default_instance();
  }
  static inline const SaveGame* internal_default_instance() {
    return reinterpret_cast<const SaveGame*>(
        &_SaveGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 29;
  friend void swap(SaveGame& a, SaveGame& b) { a.Swap(&b); }
  inline void Swap(SaveGame* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SaveGame* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SaveGame* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<SaveGame>(arena);
  }
  void CopyFrom(const SaveGame& from);
  void MergeFrom(const SaveGame& from) { SaveGame::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SaveGame* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dapi.commands.SaveGame"; }

 protected:
  explicit SaveGame(::google::protobuf::Arena* arena);
  SaveGame(::google::protobuf::Arena* arena, const SaveGame& from);
  SaveGame(::google::protobuf::Arena* arena, SaveGame&& from) noexcept
      : SaveGame(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataLite<23> _class_data_;

 public:
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:dapi.commands.SaveGame)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SaveGame& from_msg);
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class RepairItem final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:dapi.commands.RepairItem) */ {
 public:
  inline RepairItem() : RepairItem(nullptr) {}
  ~RepairItem() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RepairItem* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RepairItem));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RepairItem(
      ::google::protobuf::internal::ConstantInitialized);

  inline RepairItem(const RepairItem& from) : RepairItem(nullptr, from) {}
  inline RepairItem(RepairItem&& from) noexcept
      : RepairItem(nullptr, std::move(from)) {}
  inline RepairItem& operator=(const RepairItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline RepairItem& operator=(RepairItem&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const RepairItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const RepairItem* internal_default_instance() {
    return reinterpret_cast<const RepairItem*>(
        &_RepairItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(RepairItem& a, RepairItem& b) { a.Swap(&b); }
  inline void Swap(RepairItem* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RepairItem* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RepairItem* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<RepairItem>(arena);
  }
  void CopyFrom(const RepairItem& from);
  void MergeFrom(const RepairItem& from) { RepairItem::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RepairItem* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dapi.commands.RepairItem"; }

 protected:
  explicit RepairItem(::google::protobuf::Arena* arena);
  RepairItem(::google::protobuf::Arena* arena, const RepairItem& from);
  RepairItem(::google::protobuf::Arena* arena, RepairItem&& from) noexcept
      : RepairItem(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataLite<25> _class_data_;

 public:
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIDFieldNumber = 1,
  };
  // uint32 ID = 1;
  void clear_id() ;
  ::uint32_t id() const;
  void set_id(::uint32_t value);

  private:
  ::uint32_t _internal_id() const;
  void _internal_set_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dapi.commands.RepairItem)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RepairItem& from_msg);
    ::uint32_t id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class RechargeItem final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:dapi.commands.RechargeItem) */ {
 public:
  inline RechargeItem() : RechargeItem(nullptr) {}
  ~RechargeItem() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RechargeItem* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RechargeItem));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RechargeItem(
      ::google::protobuf::internal::ConstantInitialized);

  inline RechargeItem(const RechargeItem& from) : RechargeItem(nullptr, from) {}
  inline RechargeItem(RechargeItem&& from) noexcept
      : RechargeItem(nullptr, std::move(from)) {}
  inline RechargeItem& operator=(const RechargeItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline RechargeItem& operator=(RechargeItem&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const RechargeItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const RechargeItem* internal_default_instance() {
    return reinterpret_cast<const RechargeItem*>(
        &_RechargeItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(RechargeItem& a, RechargeItem& b) { a.Swap(&b); }
  inline void Swap(RechargeItem* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RechargeItem* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RechargeItem* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<RechargeItem>(arena);
  }
  void CopyFrom(const RechargeItem& from);
  void MergeFrom(const RechargeItem& from) { RechargeItem::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RechargeItem* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dapi.commands.RechargeItem"; }

 protected:
  explicit RechargeItem(::google::protobuf::Arena* arena);
  RechargeItem(::google::protobuf::Arena* arena, const RechargeItem& from);
  RechargeItem(::google::protobuf::Arena* arena, RechargeItem&& from) noexcept
      : RechargeItem(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataLite<27> _class_data_;

 public:
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIDFieldNumber = 1,
  };
  // uint32 ID = 1;
  void clear_id() ;
  ::uint32_t id() const;
  void set_id(::uint32_t value);

  private:
  ::uint32_t _internal_id() const;
  void _internal_set_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dapi.commands.RechargeItem)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RechargeItem& from_msg);
    ::uint32_t id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class Quit final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:dapi.commands.Quit) */ {
 public:
  inline Quit() : Quit(nullptr) {}
  ~Quit() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Quit* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Quit));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Quit(
      ::google::protobuf::internal::ConstantInitialized);

  inline Quit(const Quit& from) : Quit(nullptr, from) {}
  inline Quit(Quit&& from) noexcept
      : Quit(nullptr, std::move(from)) {}
  inline Quit& operator=(const Quit& from) {
    CopyFrom(from);
    return *this;
  }
  inline Quit& operator=(Quit&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Quit& default_instance() {
    return *internal_default_instance();
  }
  static inline const Quit* internal_default_instance() {
    return reinterpret_cast<const Quit*>(
        &_Quit_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 30;
  friend void swap(Quit& a, Quit& b) { a.Swap(&b); }
  inline void Swap(Quit* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Quit* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Quit* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<Quit>(arena);
  }
  void CopyFrom(const Quit& from);
  void MergeFrom(const Quit& from) { Quit::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Quit* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dapi.commands.Quit"; }

 protected:
  explicit Quit(::google::protobuf::Arena* arena);
  Quit(::google::protobuf::Arena* arena, const Quit& from);
  Quit(::google::protobuf::Arena* arena, Quit&& from) noexcept
      : Quit(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataLite<19> _class_data_;

 public:
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:dapi.commands.Quit)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Quit& from_msg);
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class PutInCursor final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:dapi.commands.PutInCursor) */ {
 public:
  inline PutInCursor() : PutInCursor(nullptr) {}
  ~PutInCursor() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PutInCursor* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PutInCursor));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PutInCursor(
      ::google::protobuf::internal::ConstantInitialized);

  inline PutInCursor(const PutInCursor& from) : PutInCursor(nullptr, from) {}
  inline PutInCursor(PutInCursor&& from) noexcept
      : PutInCursor(nullptr, std::move(from)) {}
  inline PutInCursor& operator=(const PutInCursor& from) {
    CopyFrom(from);
    return *this;
  }
  inline PutInCursor& operator=(PutInCursor&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PutInCursor& default_instance() {
    return *internal_default_instance();
  }
  static inline const PutInCursor* internal_default_instance() {
    return reinterpret_cast<const PutInCursor*>(
        &_PutInCursor_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(PutInCursor& a, PutInCursor& b) { a.Swap(&b); }
  inline void Swap(PutInCursor* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PutInCursor* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PutInCursor* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<PutInCursor>(arena);
  }
  void CopyFrom(const PutInCursor& from);
  void MergeFrom(const PutInCursor& from) { PutInCursor::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PutInCursor* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dapi.commands.PutInCursor"; }

 protected:
  explicit PutInCursor(::google::protobuf::Arena* arena);
  PutInCursor(::google::protobuf::Arena* arena, const PutInCursor& from);
  PutInCursor(::google::protobuf::Arena* arena, PutInCursor&& from) noexcept
      : PutInCursor(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataLite<26> _class_data_;

 public:
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIDFieldNumber = 1,
  };
  // uint32 ID = 1;
  void clear_id() ;
  ::uint32_t id() const;
  void set_id(::uint32_t value);

  private:
  ::uint32_t _internal_id() const;
  void _internal_set_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dapi.commands.PutInCursor)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PutInCursor& from_msg);
    ::uint32_t id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class PutCursorItem final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:dapi.commands.PutCursorItem) */ {
 public:
  inline PutCursorItem() : PutCursorItem(nullptr) {}
  ~PutCursorItem() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PutCursorItem* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PutCursorItem));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PutCursorItem(
      ::google::protobuf::internal::ConstantInitialized);

  inline PutCursorItem(const PutCursorItem& from) : PutCursorItem(nullptr, from) {}
  inline PutCursorItem(PutCursorItem&& from) noexcept
      : PutCursorItem(nullptr, std::move(from)) {}
  inline PutCursorItem& operator=(const PutCursorItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline PutCursorItem& operator=(PutCursorItem&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PutCursorItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const PutCursorItem* internal_default_instance() {
    return reinterpret_cast<const PutCursorItem*>(
        &_PutCursorItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(PutCursorItem& a, PutCursorItem& b) { a.Swap(&b); }
  inline void Swap(PutCursorItem* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PutCursorItem* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PutCursorItem* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<PutCursorItem>(arena);
  }
  void CopyFrom(const PutCursorItem& from);
  void MergeFrom(const PutCursorItem& from) { PutCursorItem::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PutCursorItem* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dapi.commands.PutCursorItem"; }

 protected:
  explicit PutCursorItem(::google::protobuf::Arena* arena);
  PutCursorItem(::google::protobuf::Arena* arena, const PutCursorItem& from);
  PutCursorItem(::google::protobuf::Arena* arena, PutCursorItem&& from) noexcept
      : PutCursorItem(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataLite<28> _class_data_;

 public:
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTargetFieldNumber = 1,
  };
  // sint32 target = 1;
  void clear_target() ;
  ::int32_t target() const;
  void set_target(::int32_t value);

  private:
  ::int32_t _internal_target() const;
  void _internal_set_target(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dapi.commands.PutCursorItem)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PutCursorItem& from_msg);
    ::int32_t target_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class OperateObject final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:dapi.commands.OperateObject) */ {
 public:
  inline OperateObject() : OperateObject(nullptr) {}
  ~OperateObject() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(OperateObject* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(OperateObject));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR OperateObject(
      ::google::protobuf::internal::ConstantInitialized);

  inline OperateObject(const OperateObject& from) : OperateObject(nullptr, from) {}
  inline OperateObject(OperateObject&& from) noexcept
      : OperateObject(nullptr, std::move(from)) {}
  inline OperateObject& operator=(const OperateObject& from) {
    CopyFrom(from);
    return *this;
  }
  inline OperateObject& operator=(OperateObject&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const OperateObject& default_instance() {
    return *internal_default_instance();
  }
  static inline const OperateObject* internal_default_instance() {
    return reinterpret_cast<const OperateObject*>(
        &_OperateObject_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(OperateObject& a, OperateObject& b) { a.Swap(&b); }
  inline void Swap(OperateObject* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OperateObject* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OperateObject* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<OperateObject>(arena);
  }
  void CopyFrom(const OperateObject& from);
  void MergeFrom(const OperateObject& from) { OperateObject::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(OperateObject* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dapi.commands.OperateObject"; }

 protected:
  explicit OperateObject(::google::protobuf::Arena* arena);
  OperateObject(::google::protobuf::Arena* arena, const OperateObject& from);
  OperateObject(::google::protobuf::Arena* arena, OperateObject&& from) noexcept
      : OperateObject(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataLite<28> _class_data_;

 public:
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIndexFieldNumber = 1,
  };
  // uint32 index = 1;
  void clear_index() ;
  ::uint32_t index() const;
  void set_index(::uint32_t value);

  private:
  ::uint32_t _internal_index() const;
  void _internal_set_index(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dapi.commands.OperateObject)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const OperateObject& from_msg);
    ::uint32_t index_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class Move final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:dapi.commands.Move) */ {
 public:
  inline Move() : Move(nullptr) {}
  ~Move() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Move* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Move));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Move(
      ::google::protobuf::internal::ConstantInitialized);

  inline Move(const Move& from) : Move(nullptr, from) {}
  inline Move(Move&& from) noexcept
      : Move(nullptr, std::move(from)) {}
  inline Move& operator=(const Move& from) {
    CopyFrom(from);
    return *this;
  }
  inline Move& operator=(Move&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Move& default_instance() {
    return *internal_default_instance();
  }
  static inline const Move* internal_default_instance() {
    return reinterpret_cast<const Move*>(
        &_Move_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(Move& a, Move& b) { a.Swap(&b); }
  inline void Swap(Move* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Move* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Move* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<Move>(arena);
  }
  void CopyFrom(const Move& from);
  void MergeFrom(const Move& from) { Move::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Move* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dapi.commands.Move"; }

 protected:
  explicit Move(::google::protobuf::Arena* arena);
  Move(::google::protobuf::Arena* arena, const Move& from);
  Move(::google::protobuf::Arena* arena, Move&& from) noexcept
      : Move(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataLite<19> _class_data_;

 public:
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTypeFieldNumber = 1,
    kTargetXFieldNumber = 2,
    kTargetYFieldNumber = 3,
  };
  // uint32 type = 1;
  void clear_type() ;
  ::uint32_t type() const;
  void set_type(::uint32_t value);

  private:
  ::uint32_t _internal_type() const;
  void _internal_set_type(::uint32_t value);

  public:
  // uint32 targetX = 2;
  void clear_targetx() ;
  ::uint32_t targetx() const;
  void set_targetx(::uint32_t value);

  private:
  ::uint32_t _internal_targetx() const;
  void _internal_set_targetx(::uint32_t value);

  public:
  // uint32 targetY = 3;
  void clear_targety() ;
  ::uint32_t targety() const;
  void set_targety(::uint32_t value);

  private:
  ::uint32_t _internal_targety() const;
  void _internal_set_targety(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dapi.commands.Move)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Move& from_msg);
    ::uint32_t type_;
    ::uint32_t targetx_;
    ::uint32_t targety_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class IncreaseStat final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:dapi.commands.IncreaseStat) */ {
 public:
  inline IncreaseStat() : IncreaseStat(nullptr) {}
  ~IncreaseStat() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(IncreaseStat* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(IncreaseStat));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR IncreaseStat(
      ::google::protobuf::internal::ConstantInitialized);

  inline IncreaseStat(const IncreaseStat& from) : IncreaseStat(nullptr, from) {}
  inline IncreaseStat(IncreaseStat&& from) noexcept
      : IncreaseStat(nullptr, std::move(from)) {}
  inline IncreaseStat& operator=(const IncreaseStat& from) {
    CopyFrom(from);
    return *this;
  }
  inline IncreaseStat& operator=(IncreaseStat&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const IncreaseStat& default_instance() {
    return *internal_default_instance();
  }
  static inline const IncreaseStat* internal_default_instance() {
    return reinterpret_cast<const IncreaseStat*>(
        &_IncreaseStat_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(IncreaseStat& a, IncreaseStat& b) { a.Swap(&b); }
  inline void Swap(IncreaseStat* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IncreaseStat* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IncreaseStat* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<IncreaseStat>(arena);
  }
  void CopyFrom(const IncreaseStat& from);
  void MergeFrom(const IncreaseStat& from) { IncreaseStat::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(IncreaseStat* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dapi.commands.IncreaseStat"; }

 protected:
  explicit IncreaseStat(::google::protobuf::Arena* arena);
  IncreaseStat(::google::protobuf::Arena* arena, const IncreaseStat& from);
  IncreaseStat(::google::protobuf::Arena* arena, IncreaseStat&& from) noexcept
      : IncreaseStat(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataLite<27> _class_data_;

 public:
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStatFieldNumber = 1,
  };
  // uint32 stat = 1;
  void clear_stat() ;
  ::uint32_t stat() const;
  void set_stat(::uint32_t value);

  private:
  ::uint32_t _internal_stat() const;
  void _internal_set_stat(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dapi.commands.IncreaseStat)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const IncreaseStat& from_msg);
    ::uint32_t stat_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class IdentifyStoreItem final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:dapi.commands.IdentifyStoreItem) */ {
 public:
  inline IdentifyStoreItem() : IdentifyStoreItem(nullptr) {}
  ~IdentifyStoreItem() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(IdentifyStoreItem* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(IdentifyStoreItem));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR IdentifyStoreItem(
      ::google::protobuf::internal::ConstantInitialized);

  inline IdentifyStoreItem(const IdentifyStoreItem& from) : IdentifyStoreItem(nullptr, from) {}
  inline IdentifyStoreItem(IdentifyStoreItem&& from) noexcept
      : IdentifyStoreItem(nullptr, std::move(from)) {}
  inline IdentifyStoreItem& operator=(const IdentifyStoreItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline IdentifyStoreItem& operator=(IdentifyStoreItem&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const IdentifyStoreItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const IdentifyStoreItem* internal_default_instance() {
    return reinterpret_cast<const IdentifyStoreItem*>(
        &_IdentifyStoreItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 24;
  friend void swap(IdentifyStoreItem& a, IdentifyStoreItem& b) { a.Swap(&b); }
  inline void Swap(IdentifyStoreItem* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IdentifyStoreItem* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IdentifyStoreItem* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<IdentifyStoreItem>(arena);
  }
  void CopyFrom(const IdentifyStoreItem& from);
  void MergeFrom(const IdentifyStoreItem& from) { IdentifyStoreItem::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(IdentifyStoreItem* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dapi.commands.IdentifyStoreItem"; }

 protected:
  explicit IdentifyStoreItem(::google::protobuf::Arena* arena);
  IdentifyStoreItem(::google::protobuf::Arena* arena, const IdentifyStoreItem& from);
  IdentifyStoreItem(::google::protobuf::Arena* arena, IdentifyStoreItem&& from) noexcept
      : IdentifyStoreItem(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataLite<32> _class_data_;

 public:
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIDFieldNumber = 1,
  };
  // uint32 ID = 1;
  void clear_id() ;
  ::uint32_t id() const;
  void set_id(::uint32_t value);

  private:
  ::uint32_t _internal_id() const;
  void _internal_set_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dapi.commands.IdentifyStoreItem)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const IdentifyStoreItem& from_msg);
    ::uint32_t id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class IdentifyItem final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:dapi.commands.IdentifyItem) */ {
 public:
  inline IdentifyItem() : IdentifyItem(nullptr) {}
  ~IdentifyItem() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(IdentifyItem* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(IdentifyItem));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR IdentifyItem(
      ::google::protobuf::internal::ConstantInitialized);

  inline IdentifyItem(const IdentifyItem& from) : IdentifyItem(nullptr, from) {}
  inline IdentifyItem(IdentifyItem&& from) noexcept
      : IdentifyItem(nullptr, std::move(from)) {}
  inline IdentifyItem& operator=(const IdentifyItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline IdentifyItem& operator=(IdentifyItem&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const IdentifyItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const IdentifyItem* internal_default_instance() {
    return reinterpret_cast<const IdentifyItem*>(
        &_IdentifyItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 32;
  friend void swap(IdentifyItem& a, IdentifyItem& b) { a.Swap(&b); }
  inline void Swap(IdentifyItem* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IdentifyItem* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IdentifyItem* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<IdentifyItem>(arena);
  }
  void CopyFrom(const IdentifyItem& from);
  void MergeFrom(const IdentifyItem& from) { IdentifyItem::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(IdentifyItem* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dapi.commands.IdentifyItem"; }

 protected:
  explicit IdentifyItem(::google::protobuf::Arena* arena);
  IdentifyItem(::google::protobuf::Arena* arena, const IdentifyItem& from);
  IdentifyItem(::google::protobuf::Arena* arena, IdentifyItem&& from) noexcept
      : IdentifyItem(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataLite<27> _class_data_;

 public:
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIDFieldNumber = 1,
  };
  // uint32 ID = 1;
  void clear_id() ;
  ::uint32_t id() const;
  void set_id(::uint32_t value);

  private:
  ::uint32_t _internal_id() const;
  void _internal_set_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dapi.commands.IdentifyItem)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const IdentifyItem& from_msg);
    ::uint32_t id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class GetItem final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:dapi.commands.GetItem) */ {
 public:
  inline GetItem() : GetItem(nullptr) {}
  ~GetItem() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetItem* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetItem));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetItem(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetItem(const GetItem& from) : GetItem(nullptr, from) {}
  inline GetItem(GetItem&& from) noexcept
      : GetItem(nullptr, std::move(from)) {}
  inline GetItem& operator=(const GetItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetItem& operator=(GetItem&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GetItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetItem* internal_default_instance() {
    return reinterpret_cast<const GetItem*>(
        &_GetItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(GetItem& a, GetItem& b) { a.Swap(&b); }
  inline void Swap(GetItem* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetItem* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetItem* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<GetItem>(arena);
  }
  void CopyFrom(const GetItem& from);
  void MergeFrom(const GetItem& from) { GetItem::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetItem* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dapi.commands.GetItem"; }

 protected:
  explicit GetItem(::google::protobuf::Arena* arena);
  GetItem(::google::protobuf::Arena* arena, const GetItem& from);
  GetItem(::google::protobuf::Arena* arena, GetItem&& from) noexcept
      : GetItem(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataLite<22> _class_data_;

 public:
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIDFieldNumber = 1,
  };
  // uint32 ID = 1;
  void clear_id() ;
  ::uint32_t id() const;
  void set_id(::uint32_t value);

  private:
  ::uint32_t _internal_id() const;
  void _internal_set_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dapi.commands.GetItem)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetItem& from_msg);
    ::uint32_t id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class DropCursorItem final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:dapi.commands.DropCursorItem) */ {
 public:
  inline DropCursorItem() : DropCursorItem(nullptr) {}
  ~DropCursorItem() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DropCursorItem* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DropCursorItem));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DropCursorItem(
      ::google::protobuf::internal::ConstantInitialized);

  inline DropCursorItem(const DropCursorItem& from) : DropCursorItem(nullptr, from) {}
  inline DropCursorItem(DropCursorItem&& from) noexcept
      : DropCursorItem(nullptr, std::move(from)) {}
  inline DropCursorItem& operator=(const DropCursorItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline DropCursorItem& operator=(DropCursorItem&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DropCursorItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const DropCursorItem* internal_default_instance() {
    return reinterpret_cast<const DropCursorItem*>(
        &_DropCursorItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 22;
  friend void swap(DropCursorItem& a, DropCursorItem& b) { a.Swap(&b); }
  inline void Swap(DropCursorItem* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DropCursorItem* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DropCursorItem* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<DropCursorItem>(arena);
  }
  void CopyFrom(const DropCursorItem& from);
  void MergeFrom(const DropCursorItem& from) { DropCursorItem::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DropCursorItem* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dapi.commands.DropCursorItem"; }

 protected:
  explicit DropCursorItem(::google::protobuf::Arena* arena);
  DropCursorItem(::google::protobuf::Arena* arena, const DropCursorItem& from);
  DropCursorItem(::google::protobuf::Arena* arena, DropCursorItem&& from) noexcept
      : DropCursorItem(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataLite<29> _class_data_;

 public:
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:dapi.commands.DropCursorItem)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DropCursorItem& from_msg);
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class DisarmTrap final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:dapi.commands.DisarmTrap) */ {
 public:
  inline DisarmTrap() : DisarmTrap(nullptr) {}
  ~DisarmTrap() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DisarmTrap* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DisarmTrap));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DisarmTrap(
      ::google::protobuf::internal::ConstantInitialized);

  inline DisarmTrap(const DisarmTrap& from) : DisarmTrap(nullptr, from) {}
  inline DisarmTrap(DisarmTrap&& from) noexcept
      : DisarmTrap(nullptr, std::move(from)) {}
  inline DisarmTrap& operator=(const DisarmTrap& from) {
    CopyFrom(from);
    return *this;
  }
  inline DisarmTrap& operator=(DisarmTrap&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DisarmTrap& default_instance() {
    return *internal_default_instance();
  }
  static inline const DisarmTrap* internal_default_instance() {
    return reinterpret_cast<const DisarmTrap*>(
        &_DisarmTrap_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 25;
  friend void swap(DisarmTrap& a, DisarmTrap& b) { a.Swap(&b); }
  inline void Swap(DisarmTrap* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DisarmTrap* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DisarmTrap* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<DisarmTrap>(arena);
  }
  void CopyFrom(const DisarmTrap& from);
  void MergeFrom(const DisarmTrap& from) { DisarmTrap::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DisarmTrap* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dapi.commands.DisarmTrap"; }

 protected:
  explicit DisarmTrap(::google::protobuf::Arena* arena);
  DisarmTrap(::google::protobuf::Arena* arena, const DisarmTrap& from);
  DisarmTrap(::google::protobuf::Arena* arena, DisarmTrap&& from) noexcept
      : DisarmTrap(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataLite<25> _class_data_;

 public:
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIndexFieldNumber = 1,
  };
  // uint32 index = 1;
  void clear_index() ;
  ::uint32_t index() const;
  void set_index(::uint32_t value);

  private:
  ::uint32_t _internal_index() const;
  void _internal_set_index(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dapi.commands.DisarmTrap)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DisarmTrap& from_msg);
    ::uint32_t index_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class ClearCursor final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:dapi.commands.ClearCursor) */ {
 public:
  inline ClearCursor() : ClearCursor(nullptr) {}
  ~ClearCursor() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ClearCursor* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ClearCursor));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ClearCursor(
      ::google::protobuf::internal::ConstantInitialized);

  inline ClearCursor(const ClearCursor& from) : ClearCursor(nullptr, from) {}
  inline ClearCursor(ClearCursor&& from) noexcept
      : ClearCursor(nullptr, std::move(from)) {}
  inline ClearCursor& operator=(const ClearCursor& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClearCursor& operator=(ClearCursor&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ClearCursor& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClearCursor* internal_default_instance() {
    return reinterpret_cast<const ClearCursor*>(
        &_ClearCursor_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 31;
  friend void swap(ClearCursor& a, ClearCursor& b) { a.Swap(&b); }
  inline void Swap(ClearCursor* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClearCursor* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClearCursor* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<ClearCursor>(arena);
  }
  void CopyFrom(const ClearCursor& from);
  void MergeFrom(const ClearCursor& from) { ClearCursor::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ClearCursor* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dapi.commands.ClearCursor"; }

 protected:
  explicit ClearCursor(::google::protobuf::Arena* arena);
  ClearCursor(::google::protobuf::Arena* arena, const ClearCursor& from);
  ClearCursor(::google::protobuf::Arena* arena, ClearCursor&& from) noexcept
      : ClearCursor(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataLite<26> _class_data_;

 public:
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:dapi.commands.ClearCursor)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ClearCursor& from_msg);
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class CastXY final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:dapi.commands.CastXY) */ {
 public:
  inline CastXY() : CastXY(nullptr) {}
  ~CastXY() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CastXY* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CastXY));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CastXY(
      ::google::protobuf::internal::ConstantInitialized);

  inline CastXY(const CastXY& from) : CastXY(nullptr, from) {}
  inline CastXY(CastXY&& from) noexcept
      : CastXY(nullptr, std::move(from)) {}
  inline CastXY& operator=(const CastXY& from) {
    CopyFrom(from);
    return *this;
  }
  inline CastXY& operator=(CastXY&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CastXY& default_instance() {
    return *internal_default_instance();
  }
  static inline const CastXY* internal_default_instance() {
    return reinterpret_cast<const CastXY*>(
        &_CastXY_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(CastXY& a, CastXY& b) { a.Swap(&b); }
  inline void Swap(CastXY* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CastXY* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CastXY* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<CastXY>(arena);
  }
  void CopyFrom(const CastXY& from);
  void MergeFrom(const CastXY& from) { CastXY::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CastXY* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dapi.commands.CastXY"; }

 protected:
  explicit CastXY(::google::protobuf::Arena* arena);
  CastXY(::google::protobuf::Arena* arena, const CastXY& from);
  CastXY(::google::protobuf::Arena* arena, CastXY&& from) noexcept
      : CastXY(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataLite<21> _class_data_;

 public:
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // sint32 x = 1;
  void clear_x() ;
  ::int32_t x() const;
  void set_x(::int32_t value);

  private:
  ::int32_t _internal_x() const;
  void _internal_set_x(::int32_t value);

  public:
  // sint32 y = 2;
  void clear_y() ;
  ::int32_t y() const;
  void set_y(::int32_t value);

  private:
  ::int32_t _internal_y() const;
  void _internal_set_y(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dapi.commands.CastXY)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CastXY& from_msg);
    ::int32_t x_;
    ::int32_t y_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class CastMonster final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:dapi.commands.CastMonster) */ {
 public:
  inline CastMonster() : CastMonster(nullptr) {}
  ~CastMonster() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CastMonster* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CastMonster));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CastMonster(
      ::google::protobuf::internal::ConstantInitialized);

  inline CastMonster(const CastMonster& from) : CastMonster(nullptr, from) {}
  inline CastMonster(CastMonster&& from) noexcept
      : CastMonster(nullptr, std::move(from)) {}
  inline CastMonster& operator=(const CastMonster& from) {
    CopyFrom(from);
    return *this;
  }
  inline CastMonster& operator=(CastMonster&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CastMonster& default_instance() {
    return *internal_default_instance();
  }
  static inline const CastMonster* internal_default_instance() {
    return reinterpret_cast<const CastMonster*>(
        &_CastMonster_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(CastMonster& a, CastMonster& b) { a.Swap(&b); }
  inline void Swap(CastMonster* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CastMonster* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CastMonster* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<CastMonster>(arena);
  }
  void CopyFrom(const CastMonster& from);
  void MergeFrom(const CastMonster& from) { CastMonster::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CastMonster* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dapi.commands.CastMonster"; }

 protected:
  explicit CastMonster(::google::protobuf::Arena* arena);
  CastMonster(::google::protobuf::Arena* arena, const CastMonster& from);
  CastMonster(::google::protobuf::Arena* arena, CastMonster&& from) noexcept
      : CastMonster(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataLite<26> _class_data_;

 public:
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIndexFieldNumber = 1,
  };
  // uint32 index = 1;
  void clear_index() ;
  ::uint32_t index() const;
  void set_index(::uint32_t value);

  private:
  ::uint32_t _internal_index() const;
  void _internal_set_index(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dapi.commands.CastMonster)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CastMonster& from_msg);
    ::uint32_t index_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class CancelQText final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:dapi.commands.CancelQText) */ {
 public:
  inline CancelQText() : CancelQText(nullptr) {}
  ~CancelQText() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CancelQText* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CancelQText));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CancelQText(
      ::google::protobuf::internal::ConstantInitialized);

  inline CancelQText(const CancelQText& from) : CancelQText(nullptr, from) {}
  inline CancelQText(CancelQText&& from) noexcept
      : CancelQText(nullptr, std::move(from)) {}
  inline CancelQText& operator=(const CancelQText& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelQText& operator=(CancelQText&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CancelQText& default_instance() {
    return *internal_default_instance();
  }
  static inline const CancelQText* internal_default_instance() {
    return reinterpret_cast<const CancelQText*>(
        &_CancelQText_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(CancelQText& a, CancelQText& b) { a.Swap(&b); }
  inline void Swap(CancelQText* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelQText* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CancelQText* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<CancelQText>(arena);
  }
  void CopyFrom(const CancelQText& from);
  void MergeFrom(const CancelQText& from) { CancelQText::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CancelQText* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dapi.commands.CancelQText"; }

 protected:
  explicit CancelQText(::google::protobuf::Arena* arena);
  CancelQText(::google::protobuf::Arena* arena, const CancelQText& from);
  CancelQText(::google::protobuf::Arena* arena, CancelQText&& from) noexcept
      : CancelQText(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataLite<26> _class_data_;

 public:
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:dapi.commands.CancelQText)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CancelQText& from_msg);
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class BuyItem final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:dapi.commands.BuyItem) */ {
 public:
  inline BuyItem() : BuyItem(nullptr) {}
  ~BuyItem() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BuyItem* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BuyItem));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BuyItem(
      ::google::protobuf::internal::ConstantInitialized);

  inline BuyItem(const BuyItem& from) : BuyItem(nullptr, from) {}
  inline BuyItem(BuyItem&& from) noexcept
      : BuyItem(nullptr, std::move(from)) {}
  inline BuyItem& operator=(const BuyItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline BuyItem& operator=(BuyItem&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BuyItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const BuyItem* internal_default_instance() {
    return reinterpret_cast<const BuyItem*>(
        &_BuyItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(BuyItem& a, BuyItem& b) { a.Swap(&b); }
  inline void Swap(BuyItem* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BuyItem* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BuyItem* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<BuyItem>(arena);
  }
  void CopyFrom(const BuyItem& from);
  void MergeFrom(const BuyItem& from) { BuyItem::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BuyItem* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dapi.commands.BuyItem"; }

 protected:
  explicit BuyItem(::google::protobuf::Arena* arena);
  BuyItem(::google::protobuf::Arena* arena, const BuyItem& from);
  BuyItem(::google::protobuf::Arena* arena, BuyItem&& from) noexcept
      : BuyItem(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataLite<22> _class_data_;

 public:
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIDFieldNumber = 1,
  };
  // uint32 ID = 1;
  void clear_id() ;
  ::uint32_t id() const;
  void set_id(::uint32_t value);

  private:
  ::uint32_t _internal_id() const;
  void _internal_set_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dapi.commands.BuyItem)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BuyItem& from_msg);
    ::uint32_t id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class AttackXY final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:dapi.commands.AttackXY) */ {
 public:
  inline AttackXY() : AttackXY(nullptr) {}
  ~AttackXY() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AttackXY* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AttackXY));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AttackXY(
      ::google::protobuf::internal::ConstantInitialized);

  inline AttackXY(const AttackXY& from) : AttackXY(nullptr, from) {}
  inline AttackXY(AttackXY&& from) noexcept
      : AttackXY(nullptr, std::move(from)) {}
  inline AttackXY& operator=(const AttackXY& from) {
    CopyFrom(from);
    return *this;
  }
  inline AttackXY& operator=(AttackXY&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AttackXY& default_instance() {
    return *internal_default_instance();
  }
  static inline const AttackXY* internal_default_instance() {
    return reinterpret_cast<const AttackXY*>(
        &_AttackXY_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(AttackXY& a, AttackXY& b) { a.Swap(&b); }
  inline void Swap(AttackXY* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AttackXY* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AttackXY* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<AttackXY>(arena);
  }
  void CopyFrom(const AttackXY& from);
  void MergeFrom(const AttackXY& from) { AttackXY::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AttackXY* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dapi.commands.AttackXY"; }

 protected:
  explicit AttackXY(::google::protobuf::Arena* arena);
  AttackXY(::google::protobuf::Arena* arena, const AttackXY& from);
  AttackXY(::google::protobuf::Arena* arena, AttackXY&& from) noexcept
      : AttackXY(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataLite<23> _class_data_;

 public:
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // sint32 x = 1;
  void clear_x() ;
  ::int32_t x() const;
  void set_x(::int32_t value);

  private:
  ::int32_t _internal_x() const;
  void _internal_set_x(::int32_t value);

  public:
  // sint32 y = 2;
  void clear_y() ;
  ::int32_t y() const;
  void set_y(::int32_t value);

  private:
  ::int32_t _internal_y() const;
  void _internal_set_y(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dapi.commands.AttackXY)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AttackXY& from_msg);
    ::int32_t x_;
    ::int32_t y_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class AttackMonster final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:dapi.commands.AttackMonster) */ {
 public:
  inline AttackMonster() : AttackMonster(nullptr) {}
  ~AttackMonster() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AttackMonster* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AttackMonster));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AttackMonster(
      ::google::protobuf::internal::ConstantInitialized);

  inline AttackMonster(const AttackMonster& from) : AttackMonster(nullptr, from) {}
  inline AttackMonster(AttackMonster&& from) noexcept
      : AttackMonster(nullptr, std::move(from)) {}
  inline AttackMonster& operator=(const AttackMonster& from) {
    CopyFrom(from);
    return *this;
  }
  inline AttackMonster& operator=(AttackMonster&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AttackMonster& default_instance() {
    return *internal_default_instance();
  }
  static inline const AttackMonster* internal_default_instance() {
    return reinterpret_cast<const AttackMonster*>(
        &_AttackMonster_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(AttackMonster& a, AttackMonster& b) { a.Swap(&b); }
  inline void Swap(AttackMonster* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AttackMonster* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AttackMonster* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<AttackMonster>(arena);
  }
  void CopyFrom(const AttackMonster& from);
  void MergeFrom(const AttackMonster& from) { AttackMonster::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AttackMonster* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dapi.commands.AttackMonster"; }

 protected:
  explicit AttackMonster(::google::protobuf::Arena* arena);
  AttackMonster(::google::protobuf::Arena* arena, const AttackMonster& from);
  AttackMonster(::google::protobuf::Arena* arena, AttackMonster&& from) noexcept
      : AttackMonster(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataLite<28> _class_data_;

 public:
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIndexFieldNumber = 1,
  };
  // uint32 index = 1;
  void clear_index() ;
  ::uint32_t index() const;
  void set_index(::uint32_t value);

  private:
  ::uint32_t _internal_index() const;
  void _internal_set_index(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:dapi.commands.AttackMonster)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AttackMonster& from_msg);
    ::uint32_t index_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class Command final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:dapi.commands.Command) */ {
 public:
  inline Command() : Command(nullptr) {}
  ~Command() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Command* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Command));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Command(
      ::google::protobuf::internal::ConstantInitialized);

  inline Command(const Command& from) : Command(nullptr, from) {}
  inline Command(Command&& from) noexcept
      : Command(nullptr, std::move(from)) {}
  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }
  inline Command& operator=(Command&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Command& default_instance() {
    return *internal_default_instance();
  }
  enum CommandCase {
    kMove = 1,
    kTalk = 2,
    kOption = 3,
    kBuyItem = 4,
    kSellItem = 5,
    kRechargeItem = 6,
    kRepairItem = 7,
    kAttackMonster = 8,
    kAttackXY = 9,
    kOperateObject = 10,
    kUseBeltItem = 11,
    kToggleCharacterSheet = 12,
    kIncreaseStat = 13,
    kGetItem = 14,
    kSetSpell = 15,
    kCastMonster = 16,
    kCastXY = 17,
    kToggleInventory = 18,
    kPutInCursor = 19,
    kPutCursorItem = 20,
    kDropCursorItem = 21,
    kUseItem = 22,
    kIdentifyStoreItem = 23,
    kCancelQText = 24,
    kSetFPS = 25,
    kDisarmTrap = 26,
    kSkillRepair = 27,
    kSkillRecharge = 28,
    kToggleMenu = 29,
    kSaveGame = 30,
    kQuit = 31,
    kClearCursor = 32,
    kIdentifyItem = 33,
    COMMAND_NOT_SET = 0,
  };
  static inline const Command* internal_default_instance() {
    return reinterpret_cast<const Command*>(
        &_Command_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 33;
  friend void swap(Command& a, Command& b) { a.Swap(&b); }
  inline void Swap(Command* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Command* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Command* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::MessageLite::DefaultConstruct<Command>(arena);
  }
  void CopyFrom(const Command& from);
  void MergeFrom(const Command& from) { Command::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Command* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "dapi.commands.Command"; }

 protected:
  explicit Command(::google::protobuf::Arena* arena);
  Command(::google::protobuf::Arena* arena, const Command& from);
  Command(::google::protobuf::Arena* arena, Command&& from) noexcept
      : Command(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataLite<22> _class_data_;

 public:
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMoveFieldNumber = 1,
    kTalkFieldNumber = 2,
    kOptionFieldNumber = 3,
    kBuyItemFieldNumber = 4,
    kSellItemFieldNumber = 5,
    kRechargeItemFieldNumber = 6,
    kRepairItemFieldNumber = 7,
    kAttackMonsterFieldNumber = 8,
    kAttackXYFieldNumber = 9,
    kOperateObjectFieldNumber = 10,
    kUseBeltItemFieldNumber = 11,
    kToggleCharacterSheetFieldNumber = 12,
    kIncreaseStatFieldNumber = 13,
    kGetItemFieldNumber = 14,
    kSetSpellFieldNumber = 15,
    kCastMonsterFieldNumber = 16,
    kCastXYFieldNumber = 17,
    kToggleInventoryFieldNumber = 18,
    kPutInCursorFieldNumber = 19,
    kPutCursorItemFieldNumber = 20,
    kDropCursorItemFieldNumber = 21,
    kUseItemFieldNumber = 22,
    kIdentifyStoreItemFieldNumber = 23,
    kCancelQTextFieldNumber = 24,
    kSetFPSFieldNumber = 25,
    kDisarmTrapFieldNumber = 26,
    kSkillRepairFieldNumber = 27,
    kSkillRechargeFieldNumber = 28,
    kToggleMenuFieldNumber = 29,
    kSaveGameFieldNumber = 30,
    kQuitFieldNumber = 31,
    kClearCursorFieldNumber = 32,
    kIdentifyItemFieldNumber = 33,
  };
  // .dapi.commands.Move move = 1;
  bool has_move() const;
  private:
  bool _internal_has_move() const;

  public:
  void clear_move() ;
  const ::dapi::commands::Move& move() const;
  PROTOBUF_NODISCARD ::dapi::commands::Move* release_move();
  ::dapi::commands::Move* mutable_move();
  void set_allocated_move(::dapi::commands::Move* value);
  void unsafe_arena_set_allocated_move(::dapi::commands::Move* value);
  ::dapi::commands::Move* unsafe_arena_release_move();

  private:
  const ::dapi::commands::Move& _internal_move() const;
  ::dapi::commands::Move* _internal_mutable_move();

  public:
  // .dapi.commands.Talk talk = 2;
  bool has_talk() const;
  private:
  bool _internal_has_talk() const;

  public:
  void clear_talk() ;
  const ::dapi::commands::Talk& talk() const;
  PROTOBUF_NODISCARD ::dapi::commands::Talk* release_talk();
  ::dapi::commands::Talk* mutable_talk();
  void set_allocated_talk(::dapi::commands::Talk* value);
  void unsafe_arena_set_allocated_talk(::dapi::commands::Talk* value);
  ::dapi::commands::Talk* unsafe_arena_release_talk();

  private:
  const ::dapi::commands::Talk& _internal_talk() const;
  ::dapi::commands::Talk* _internal_mutable_talk();

  public:
  // .dapi.commands.SelectStoreOption option = 3;
  bool has_option() const;
  private:
  bool _internal_has_option() const;

  public:
  void clear_option() ;
  const ::dapi::commands::SelectStoreOption& option() const;
  PROTOBUF_NODISCARD ::dapi::commands::SelectStoreOption* release_option();
  ::dapi::commands::SelectStoreOption* mutable_option();
  void set_allocated_option(::dapi::commands::SelectStoreOption* value);
  void unsafe_arena_set_allocated_option(::dapi::commands::SelectStoreOption* value);
  ::dapi::commands::SelectStoreOption* unsafe_arena_release_option();

  private:
  const ::dapi::commands::SelectStoreOption& _internal_option() const;
  ::dapi::commands::SelectStoreOption* _internal_mutable_option();

  public:
  // .dapi.commands.BuyItem buyItem = 4;
  bool has_buyitem() const;
  private:
  bool _internal_has_buyitem() const;

  public:
  void clear_buyitem() ;
  const ::dapi::commands::BuyItem& buyitem() const;
  PROTOBUF_NODISCARD ::dapi::commands::BuyItem* release_buyitem();
  ::dapi::commands::BuyItem* mutable_buyitem();
  void set_allocated_buyitem(::dapi::commands::BuyItem* value);
  void unsafe_arena_set_allocated_buyitem(::dapi::commands::BuyItem* value);
  ::dapi::commands::BuyItem* unsafe_arena_release_buyitem();

  private:
  const ::dapi::commands::BuyItem& _internal_buyitem() const;
  ::dapi::commands::BuyItem* _internal_mutable_buyitem();

  public:
  // .dapi.commands.SellItem sellItem = 5;
  bool has_sellitem() const;
  private:
  bool _internal_has_sellitem() const;

  public:
  void clear_sellitem() ;
  const ::dapi::commands::SellItem& sellitem() const;
  PROTOBUF_NODISCARD ::dapi::commands::SellItem* release_sellitem();
  ::dapi::commands::SellItem* mutable_sellitem();
  void set_allocated_sellitem(::dapi::commands::SellItem* value);
  void unsafe_arena_set_allocated_sellitem(::dapi::commands::SellItem* value);
  ::dapi::commands::SellItem* unsafe_arena_release_sellitem();

  private:
  const ::dapi::commands::SellItem& _internal_sellitem() const;
  ::dapi::commands::SellItem* _internal_mutable_sellitem();

  public:
  // .dapi.commands.RechargeItem rechargeItem = 6;
  bool has_rechargeitem() const;
  private:
  bool _internal_has_rechargeitem() const;

  public:
  void clear_rechargeitem() ;
  const ::dapi::commands::RechargeItem& rechargeitem() const;
  PROTOBUF_NODISCARD ::dapi::commands::RechargeItem* release_rechargeitem();
  ::dapi::commands::RechargeItem* mutable_rechargeitem();
  void set_allocated_rechargeitem(::dapi::commands::RechargeItem* value);
  void unsafe_arena_set_allocated_rechargeitem(::dapi::commands::RechargeItem* value);
  ::dapi::commands::RechargeItem* unsafe_arena_release_rechargeitem();

  private:
  const ::dapi::commands::RechargeItem& _internal_rechargeitem() const;
  ::dapi::commands::RechargeItem* _internal_mutable_rechargeitem();

  public:
  // .dapi.commands.RepairItem repairItem = 7;
  bool has_repairitem() const;
  private:
  bool _internal_has_repairitem() const;

  public:
  void clear_repairitem() ;
  const ::dapi::commands::RepairItem& repairitem() const;
  PROTOBUF_NODISCARD ::dapi::commands::RepairItem* release_repairitem();
  ::dapi::commands::RepairItem* mutable_repairitem();
  void set_allocated_repairitem(::dapi::commands::RepairItem* value);
  void unsafe_arena_set_allocated_repairitem(::dapi::commands::RepairItem* value);
  ::dapi::commands::RepairItem* unsafe_arena_release_repairitem();

  private:
  const ::dapi::commands::RepairItem& _internal_repairitem() const;
  ::dapi::commands::RepairItem* _internal_mutable_repairitem();

  public:
  // .dapi.commands.AttackMonster attackMonster = 8;
  bool has_attackmonster() const;
  private:
  bool _internal_has_attackmonster() const;

  public:
  void clear_attackmonster() ;
  const ::dapi::commands::AttackMonster& attackmonster() const;
  PROTOBUF_NODISCARD ::dapi::commands::AttackMonster* release_attackmonster();
  ::dapi::commands::AttackMonster* mutable_attackmonster();
  void set_allocated_attackmonster(::dapi::commands::AttackMonster* value);
  void unsafe_arena_set_allocated_attackmonster(::dapi::commands::AttackMonster* value);
  ::dapi::commands::AttackMonster* unsafe_arena_release_attackmonster();

  private:
  const ::dapi::commands::AttackMonster& _internal_attackmonster() const;
  ::dapi::commands::AttackMonster* _internal_mutable_attackmonster();

  public:
  // .dapi.commands.AttackXY attackXY = 9;
  bool has_attackxy() const;
  private:
  bool _internal_has_attackxy() const;

  public:
  void clear_attackxy() ;
  const ::dapi::commands::AttackXY& attackxy() const;
  PROTOBUF_NODISCARD ::dapi::commands::AttackXY* release_attackxy();
  ::dapi::commands::AttackXY* mutable_attackxy();
  void set_allocated_attackxy(::dapi::commands::AttackXY* value);
  void unsafe_arena_set_allocated_attackxy(::dapi::commands::AttackXY* value);
  ::dapi::commands::AttackXY* unsafe_arena_release_attackxy();

  private:
  const ::dapi::commands::AttackXY& _internal_attackxy() const;
  ::dapi::commands::AttackXY* _internal_mutable_attackxy();

  public:
  // .dapi.commands.OperateObject operateObject = 10;
  bool has_operateobject() const;
  private:
  bool _internal_has_operateobject() const;

  public:
  void clear_operateobject() ;
  const ::dapi::commands::OperateObject& operateobject() const;
  PROTOBUF_NODISCARD ::dapi::commands::OperateObject* release_operateobject();
  ::dapi::commands::OperateObject* mutable_operateobject();
  void set_allocated_operateobject(::dapi::commands::OperateObject* value);
  void unsafe_arena_set_allocated_operateobject(::dapi::commands::OperateObject* value);
  ::dapi::commands::OperateObject* unsafe_arena_release_operateobject();

  private:
  const ::dapi::commands::OperateObject& _internal_operateobject() const;
  ::dapi::commands::OperateObject* _internal_mutable_operateobject();

  public:
  // .dapi.commands.UseBeltItem useBeltItem = 11;
  bool has_usebeltitem() const;
  private:
  bool _internal_has_usebeltitem() const;

  public:
  void clear_usebeltitem() ;
  const ::dapi::commands::UseBeltItem& usebeltitem() const;
  PROTOBUF_NODISCARD ::dapi::commands::UseBeltItem* release_usebeltitem();
  ::dapi::commands::UseBeltItem* mutable_usebeltitem();
  void set_allocated_usebeltitem(::dapi::commands::UseBeltItem* value);
  void unsafe_arena_set_allocated_usebeltitem(::dapi::commands::UseBeltItem* value);
  ::dapi::commands::UseBeltItem* unsafe_arena_release_usebeltitem();

  private:
  const ::dapi::commands::UseBeltItem& _internal_usebeltitem() const;
  ::dapi::commands::UseBeltItem* _internal_mutable_usebeltitem();

  public:
  // .dapi.commands.ToggleCharacterSheet toggleCharacterSheet = 12;
  bool has_togglecharactersheet() const;
  private:
  bool _internal_has_togglecharactersheet() const;

  public:
  void clear_togglecharactersheet() ;
  const ::dapi::commands::ToggleCharacterSheet& togglecharactersheet() const;
  PROTOBUF_NODISCARD ::dapi::commands::ToggleCharacterSheet* release_togglecharactersheet();
  ::dapi::commands::ToggleCharacterSheet* mutable_togglecharactersheet();
  void set_allocated_togglecharactersheet(::dapi::commands::ToggleCharacterSheet* value);
  void unsafe_arena_set_allocated_togglecharactersheet(::dapi::commands::ToggleCharacterSheet* value);
  ::dapi::commands::ToggleCharacterSheet* unsafe_arena_release_togglecharactersheet();

  private:
  const ::dapi::commands::ToggleCharacterSheet& _internal_togglecharactersheet() const;
  ::dapi::commands::ToggleCharacterSheet* _internal_mutable_togglecharactersheet();

  public:
  // .dapi.commands.IncreaseStat increaseStat = 13;
  bool has_increasestat() const;
  private:
  bool _internal_has_increasestat() const;

  public:
  void clear_increasestat() ;
  const ::dapi::commands::IncreaseStat& increasestat() const;
  PROTOBUF_NODISCARD ::dapi::commands::IncreaseStat* release_increasestat();
  ::dapi::commands::IncreaseStat* mutable_increasestat();
  void set_allocated_increasestat(::dapi::commands::IncreaseStat* value);
  void unsafe_arena_set_allocated_increasestat(::dapi::commands::IncreaseStat* value);
  ::dapi::commands::IncreaseStat* unsafe_arena_release_increasestat();

  private:
  const ::dapi::commands::IncreaseStat& _internal_increasestat() const;
  ::dapi::commands::IncreaseStat* _internal_mutable_increasestat();

  public:
  // .dapi.commands.GetItem getItem = 14;
  bool has_getitem() const;
  private:
  bool _internal_has_getitem() const;

  public:
  void clear_getitem() ;
  const ::dapi::commands::GetItem& getitem() const;
  PROTOBUF_NODISCARD ::dapi::commands::GetItem* release_getitem();
  ::dapi::commands::GetItem* mutable_getitem();
  void set_allocated_getitem(::dapi::commands::GetItem* value);
  void unsafe_arena_set_allocated_getitem(::dapi::commands::GetItem* value);
  ::dapi::commands::GetItem* unsafe_arena_release_getitem();

  private:
  const ::dapi::commands::GetItem& _internal_getitem() const;
  ::dapi::commands::GetItem* _internal_mutable_getitem();

  public:
  // .dapi.commands.SetSpell setSpell = 15;
  bool has_setspell() const;
  private:
  bool _internal_has_setspell() const;

  public:
  void clear_setspell() ;
  const ::dapi::commands::SetSpell& setspell() const;
  PROTOBUF_NODISCARD ::dapi::commands::SetSpell* release_setspell();
  ::dapi::commands::SetSpell* mutable_setspell();
  void set_allocated_setspell(::dapi::commands::SetSpell* value);
  void unsafe_arena_set_allocated_setspell(::dapi::commands::SetSpell* value);
  ::dapi::commands::SetSpell* unsafe_arena_release_setspell();

  private:
  const ::dapi::commands::SetSpell& _internal_setspell() const;
  ::dapi::commands::SetSpell* _internal_mutable_setspell();

  public:
  // .dapi.commands.CastMonster castMonster = 16;
  bool has_castmonster() const;
  private:
  bool _internal_has_castmonster() const;

  public:
  void clear_castmonster() ;
  const ::dapi::commands::CastMonster& castmonster() const;
  PROTOBUF_NODISCARD ::dapi::commands::CastMonster* release_castmonster();
  ::dapi::commands::CastMonster* mutable_castmonster();
  void set_allocated_castmonster(::dapi::commands::CastMonster* value);
  void unsafe_arena_set_allocated_castmonster(::dapi::commands::CastMonster* value);
  ::dapi::commands::CastMonster* unsafe_arena_release_castmonster();

  private:
  const ::dapi::commands::CastMonster& _internal_castmonster() const;
  ::dapi::commands::CastMonster* _internal_mutable_castmonster();

  public:
  // .dapi.commands.CastXY castXY = 17;
  bool has_castxy() const;
  private:
  bool _internal_has_castxy() const;

  public:
  void clear_castxy() ;
  const ::dapi::commands::CastXY& castxy() const;
  PROTOBUF_NODISCARD ::dapi::commands::CastXY* release_castxy();
  ::dapi::commands::CastXY* mutable_castxy();
  void set_allocated_castxy(::dapi::commands::CastXY* value);
  void unsafe_arena_set_allocated_castxy(::dapi::commands::CastXY* value);
  ::dapi::commands::CastXY* unsafe_arena_release_castxy();

  private:
  const ::dapi::commands::CastXY& _internal_castxy() const;
  ::dapi::commands::CastXY* _internal_mutable_castxy();

  public:
  // .dapi.commands.ToggleInventory toggleInventory = 18;
  bool has_toggleinventory() const;
  private:
  bool _internal_has_toggleinventory() const;

  public:
  void clear_toggleinventory() ;
  const ::dapi::commands::ToggleInventory& toggleinventory() const;
  PROTOBUF_NODISCARD ::dapi::commands::ToggleInventory* release_toggleinventory();
  ::dapi::commands::ToggleInventory* mutable_toggleinventory();
  void set_allocated_toggleinventory(::dapi::commands::ToggleInventory* value);
  void unsafe_arena_set_allocated_toggleinventory(::dapi::commands::ToggleInventory* value);
  ::dapi::commands::ToggleInventory* unsafe_arena_release_toggleinventory();

  private:
  const ::dapi::commands::ToggleInventory& _internal_toggleinventory() const;
  ::dapi::commands::ToggleInventory* _internal_mutable_toggleinventory();

  public:
  // .dapi.commands.PutInCursor putInCursor = 19;
  bool has_putincursor() const;
  private:
  bool _internal_has_putincursor() const;

  public:
  void clear_putincursor() ;
  const ::dapi::commands::PutInCursor& putincursor() const;
  PROTOBUF_NODISCARD ::dapi::commands::PutInCursor* release_putincursor();
  ::dapi::commands::PutInCursor* mutable_putincursor();
  void set_allocated_putincursor(::dapi::commands::PutInCursor* value);
  void unsafe_arena_set_allocated_putincursor(::dapi::commands::PutInCursor* value);
  ::dapi::commands::PutInCursor* unsafe_arena_release_putincursor();

  private:
  const ::dapi::commands::PutInCursor& _internal_putincursor() const;
  ::dapi::commands::PutInCursor* _internal_mutable_putincursor();

  public:
  // .dapi.commands.PutCursorItem putCursorItem = 20;
  bool has_putcursoritem() const;
  private:
  bool _internal_has_putcursoritem() const;

  public:
  void clear_putcursoritem() ;
  const ::dapi::commands::PutCursorItem& putcursoritem() const;
  PROTOBUF_NODISCARD ::dapi::commands::PutCursorItem* release_putcursoritem();
  ::dapi::commands::PutCursorItem* mutable_putcursoritem();
  void set_allocated_putcursoritem(::dapi::commands::PutCursorItem* value);
  void unsafe_arena_set_allocated_putcursoritem(::dapi::commands::PutCursorItem* value);
  ::dapi::commands::PutCursorItem* unsafe_arena_release_putcursoritem();

  private:
  const ::dapi::commands::PutCursorItem& _internal_putcursoritem() const;
  ::dapi::commands::PutCursorItem* _internal_mutable_putcursoritem();

  public:
  // .dapi.commands.DropCursorItem dropCursorItem = 21;
  bool has_dropcursoritem() const;
  private:
  bool _internal_has_dropcursoritem() const;

  public:
  void clear_dropcursoritem() ;
  const ::dapi::commands::DropCursorItem& dropcursoritem() const;
  PROTOBUF_NODISCARD ::dapi::commands::DropCursorItem* release_dropcursoritem();
  ::dapi::commands::DropCursorItem* mutable_dropcursoritem();
  void set_allocated_dropcursoritem(::dapi::commands::DropCursorItem* value);
  void unsafe_arena_set_allocated_dropcursoritem(::dapi::commands::DropCursorItem* value);
  ::dapi::commands::DropCursorItem* unsafe_arena_release_dropcursoritem();

  private:
  const ::dapi::commands::DropCursorItem& _internal_dropcursoritem() const;
  ::dapi::commands::DropCursorItem* _internal_mutable_dropcursoritem();

  public:
  // .dapi.commands.UseItem useItem = 22;
  bool has_useitem() const;
  private:
  bool _internal_has_useitem() const;

  public:
  void clear_useitem() ;
  const ::dapi::commands::UseItem& useitem() const;
  PROTOBUF_NODISCARD ::dapi::commands::UseItem* release_useitem();
  ::dapi::commands::UseItem* mutable_useitem();
  void set_allocated_useitem(::dapi::commands::UseItem* value);
  void unsafe_arena_set_allocated_useitem(::dapi::commands::UseItem* value);
  ::dapi::commands::UseItem* unsafe_arena_release_useitem();

  private:
  const ::dapi::commands::UseItem& _internal_useitem() const;
  ::dapi::commands::UseItem* _internal_mutable_useitem();

  public:
  // .dapi.commands.IdentifyStoreItem identifyStoreItem = 23;
  bool has_identifystoreitem() const;
  private:
  bool _internal_has_identifystoreitem() const;

  public:
  void clear_identifystoreitem() ;
  const ::dapi::commands::IdentifyStoreItem& identifystoreitem() const;
  PROTOBUF_NODISCARD ::dapi::commands::IdentifyStoreItem* release_identifystoreitem();
  ::dapi::commands::IdentifyStoreItem* mutable_identifystoreitem();
  void set_allocated_identifystoreitem(::dapi::commands::IdentifyStoreItem* value);
  void unsafe_arena_set_allocated_identifystoreitem(::dapi::commands::IdentifyStoreItem* value);
  ::dapi::commands::IdentifyStoreItem* unsafe_arena_release_identifystoreitem();

  private:
  const ::dapi::commands::IdentifyStoreItem& _internal_identifystoreitem() const;
  ::dapi::commands::IdentifyStoreItem* _internal_mutable_identifystoreitem();

  public:
  // .dapi.commands.CancelQText cancelQText = 24;
  bool has_cancelqtext() const;
  private:
  bool _internal_has_cancelqtext() const;

  public:
  void clear_cancelqtext() ;
  const ::dapi::commands::CancelQText& cancelqtext() const;
  PROTOBUF_NODISCARD ::dapi::commands::CancelQText* release_cancelqtext();
  ::dapi::commands::CancelQText* mutable_cancelqtext();
  void set_allocated_cancelqtext(::dapi::commands::CancelQText* value);
  void unsafe_arena_set_allocated_cancelqtext(::dapi::commands::CancelQText* value);
  ::dapi::commands::CancelQText* unsafe_arena_release_cancelqtext();

  private:
  const ::dapi::commands::CancelQText& _internal_cancelqtext() const;
  ::dapi::commands::CancelQText* _internal_mutable_cancelqtext();

  public:
  // .dapi.commands.SetFPS setFPS = 25;
  bool has_setfps() const;
  private:
  bool _internal_has_setfps() const;

  public:
  void clear_setfps() ;
  const ::dapi::commands::SetFPS& setfps() const;
  PROTOBUF_NODISCARD ::dapi::commands::SetFPS* release_setfps();
  ::dapi::commands::SetFPS* mutable_setfps();
  void set_allocated_setfps(::dapi::commands::SetFPS* value);
  void unsafe_arena_set_allocated_setfps(::dapi::commands::SetFPS* value);
  ::dapi::commands::SetFPS* unsafe_arena_release_setfps();

  private:
  const ::dapi::commands::SetFPS& _internal_setfps() const;
  ::dapi::commands::SetFPS* _internal_mutable_setfps();

  public:
  // .dapi.commands.DisarmTrap disarmTrap = 26;
  bool has_disarmtrap() const;
  private:
  bool _internal_has_disarmtrap() const;

  public:
  void clear_disarmtrap() ;
  const ::dapi::commands::DisarmTrap& disarmtrap() const;
  PROTOBUF_NODISCARD ::dapi::commands::DisarmTrap* release_disarmtrap();
  ::dapi::commands::DisarmTrap* mutable_disarmtrap();
  void set_allocated_disarmtrap(::dapi::commands::DisarmTrap* value);
  void unsafe_arena_set_allocated_disarmtrap(::dapi::commands::DisarmTrap* value);
  ::dapi::commands::DisarmTrap* unsafe_arena_release_disarmtrap();

  private:
  const ::dapi::commands::DisarmTrap& _internal_disarmtrap() const;
  ::dapi::commands::DisarmTrap* _internal_mutable_disarmtrap();

  public:
  // .dapi.commands.SkillRepair skillRepair = 27;
  bool has_skillrepair() const;
  private:
  bool _internal_has_skillrepair() const;

  public:
  void clear_skillrepair() ;
  const ::dapi::commands::SkillRepair& skillrepair() const;
  PROTOBUF_NODISCARD ::dapi::commands::SkillRepair* release_skillrepair();
  ::dapi::commands::SkillRepair* mutable_skillrepair();
  void set_allocated_skillrepair(::dapi::commands::SkillRepair* value);
  void unsafe_arena_set_allocated_skillrepair(::dapi::commands::SkillRepair* value);
  ::dapi::commands::SkillRepair* unsafe_arena_release_skillrepair();

  private:
  const ::dapi::commands::SkillRepair& _internal_skillrepair() const;
  ::dapi::commands::SkillRepair* _internal_mutable_skillrepair();

  public:
  // .dapi.commands.SkillRecharge skillRecharge = 28;
  bool has_skillrecharge() const;
  private:
  bool _internal_has_skillrecharge() const;

  public:
  void clear_skillrecharge() ;
  const ::dapi::commands::SkillRecharge& skillrecharge() const;
  PROTOBUF_NODISCARD ::dapi::commands::SkillRecharge* release_skillrecharge();
  ::dapi::commands::SkillRecharge* mutable_skillrecharge();
  void set_allocated_skillrecharge(::dapi::commands::SkillRecharge* value);
  void unsafe_arena_set_allocated_skillrecharge(::dapi::commands::SkillRecharge* value);
  ::dapi::commands::SkillRecharge* unsafe_arena_release_skillrecharge();

  private:
  const ::dapi::commands::SkillRecharge& _internal_skillrecharge() const;
  ::dapi::commands::SkillRecharge* _internal_mutable_skillrecharge();

  public:
  // .dapi.commands.ToggleMenu toggleMenu = 29;
  bool has_togglemenu() const;
  private:
  bool _internal_has_togglemenu() const;

  public:
  void clear_togglemenu() ;
  const ::dapi::commands::ToggleMenu& togglemenu() const;
  PROTOBUF_NODISCARD ::dapi::commands::ToggleMenu* release_togglemenu();
  ::dapi::commands::ToggleMenu* mutable_togglemenu();
  void set_allocated_togglemenu(::dapi::commands::ToggleMenu* value);
  void unsafe_arena_set_allocated_togglemenu(::dapi::commands::ToggleMenu* value);
  ::dapi::commands::ToggleMenu* unsafe_arena_release_togglemenu();

  private:
  const ::dapi::commands::ToggleMenu& _internal_togglemenu() const;
  ::dapi::commands::ToggleMenu* _internal_mutable_togglemenu();

  public:
  // .dapi.commands.SaveGame saveGame = 30;
  bool has_savegame() const;
  private:
  bool _internal_has_savegame() const;

  public:
  void clear_savegame() ;
  const ::dapi::commands::SaveGame& savegame() const;
  PROTOBUF_NODISCARD ::dapi::commands::SaveGame* release_savegame();
  ::dapi::commands::SaveGame* mutable_savegame();
  void set_allocated_savegame(::dapi::commands::SaveGame* value);
  void unsafe_arena_set_allocated_savegame(::dapi::commands::SaveGame* value);
  ::dapi::commands::SaveGame* unsafe_arena_release_savegame();

  private:
  const ::dapi::commands::SaveGame& _internal_savegame() const;
  ::dapi::commands::SaveGame* _internal_mutable_savegame();

  public:
  // .dapi.commands.Quit quit = 31;
  bool has_quit() const;
  private:
  bool _internal_has_quit() const;

  public:
  void clear_quit() ;
  const ::dapi::commands::Quit& quit() const;
  PROTOBUF_NODISCARD ::dapi::commands::Quit* release_quit();
  ::dapi::commands::Quit* mutable_quit();
  void set_allocated_quit(::dapi::commands::Quit* value);
  void unsafe_arena_set_allocated_quit(::dapi::commands::Quit* value);
  ::dapi::commands::Quit* unsafe_arena_release_quit();

  private:
  const ::dapi::commands::Quit& _internal_quit() const;
  ::dapi::commands::Quit* _internal_mutable_quit();

  public:
  // .dapi.commands.ClearCursor clearCursor = 32;
  bool has_clearcursor() const;
  private:
  bool _internal_has_clearcursor() const;

  public:
  void clear_clearcursor() ;
  const ::dapi::commands::ClearCursor& clearcursor() const;
  PROTOBUF_NODISCARD ::dapi::commands::ClearCursor* release_clearcursor();
  ::dapi::commands::ClearCursor* mutable_clearcursor();
  void set_allocated_clearcursor(::dapi::commands::ClearCursor* value);
  void unsafe_arena_set_allocated_clearcursor(::dapi::commands::ClearCursor* value);
  ::dapi::commands::ClearCursor* unsafe_arena_release_clearcursor();

  private:
  const ::dapi::commands::ClearCursor& _internal_clearcursor() const;
  ::dapi::commands::ClearCursor* _internal_mutable_clearcursor();

  public:
  // .dapi.commands.IdentifyItem identifyItem = 33;
  bool has_identifyitem() const;
  private:
  bool _internal_has_identifyitem() const;

  public:
  void clear_identifyitem() ;
  const ::dapi::commands::IdentifyItem& identifyitem() const;
  PROTOBUF_NODISCARD ::dapi::commands::IdentifyItem* release_identifyitem();
  ::dapi::commands::IdentifyItem* mutable_identifyitem();
  void set_allocated_identifyitem(::dapi::commands::IdentifyItem* value);
  void unsafe_arena_set_allocated_identifyitem(::dapi::commands::IdentifyItem* value);
  ::dapi::commands::IdentifyItem* unsafe_arena_release_identifyitem();

  private:
  const ::dapi::commands::IdentifyItem& _internal_identifyitem() const;
  ::dapi::commands::IdentifyItem* _internal_mutable_identifyitem();

  public:
  void clear_command();
  CommandCase command_case() const;
  // @@protoc_insertion_point(class_scope:dapi.commands.Command)
 private:
  class _Internal;
  void set_has_move();
  void set_has_talk();
  void set_has_option();
  void set_has_buyitem();
  void set_has_sellitem();
  void set_has_rechargeitem();
  void set_has_repairitem();
  void set_has_attackmonster();
  void set_has_attackxy();
  void set_has_operateobject();
  void set_has_usebeltitem();
  void set_has_togglecharactersheet();
  void set_has_increasestat();
  void set_has_getitem();
  void set_has_setspell();
  void set_has_castmonster();
  void set_has_castxy();
  void set_has_toggleinventory();
  void set_has_putincursor();
  void set_has_putcursoritem();
  void set_has_dropcursoritem();
  void set_has_useitem();
  void set_has_identifystoreitem();
  void set_has_cancelqtext();
  void set_has_setfps();
  void set_has_disarmtrap();
  void set_has_skillrepair();
  void set_has_skillrecharge();
  void set_has_togglemenu();
  void set_has_savegame();
  void set_has_quit();
  void set_has_clearcursor();
  void set_has_identifyitem();
  inline bool has_command() const;
  inline void clear_has_command();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 33, 33,
      0, 7>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Command& from_msg);
    union CommandUnion {
      constexpr CommandUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::dapi::commands::Move* move_;
      ::dapi::commands::Talk* talk_;
      ::dapi::commands::SelectStoreOption* option_;
      ::dapi::commands::BuyItem* buyitem_;
      ::dapi::commands::SellItem* sellitem_;
      ::dapi::commands::RechargeItem* rechargeitem_;
      ::dapi::commands::RepairItem* repairitem_;
      ::dapi::commands::AttackMonster* attackmonster_;
      ::dapi::commands::AttackXY* attackxy_;
      ::dapi::commands::OperateObject* operateobject_;
      ::dapi::commands::UseBeltItem* usebeltitem_;
      ::dapi::commands::ToggleCharacterSheet* togglecharactersheet_;
      ::dapi::commands::IncreaseStat* increasestat_;
      ::dapi::commands::GetItem* getitem_;
      ::dapi::commands::SetSpell* setspell_;
      ::dapi::commands::CastMonster* castmonster_;
      ::dapi::commands::CastXY* castxy_;
      ::dapi::commands::ToggleInventory* toggleinventory_;
      ::dapi::commands::PutInCursor* putincursor_;
      ::dapi::commands::PutCursorItem* putcursoritem_;
      ::dapi::commands::DropCursorItem* dropcursoritem_;
      ::dapi::commands::UseItem* useitem_;
      ::dapi::commands::IdentifyStoreItem* identifystoreitem_;
      ::dapi::commands::CancelQText* cancelqtext_;
      ::dapi::commands::SetFPS* setfps_;
      ::dapi::commands::DisarmTrap* disarmtrap_;
      ::dapi::commands::SkillRepair* skillrepair_;
      ::dapi::commands::SkillRecharge* skillrecharge_;
      ::dapi::commands::ToggleMenu* togglemenu_;
      ::dapi::commands::SaveGame* savegame_;
      ::dapi::commands::Quit* quit_;
      ::dapi::commands::ClearCursor* clearcursor_;
      ::dapi::commands::IdentifyItem* identifyitem_;
    } command_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_command_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// SetFPS

// uint32 FPS = 1;
inline void SetFPS::clear_fps() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fps_ = 0u;
}
inline ::uint32_t SetFPS::fps() const {
  // @@protoc_insertion_point(field_get:dapi.commands.SetFPS.FPS)
  return _internal_fps();
}
inline void SetFPS::set_fps(::uint32_t value) {
  _internal_set_fps(value);
  // @@protoc_insertion_point(field_set:dapi.commands.SetFPS.FPS)
}
inline ::uint32_t SetFPS::_internal_fps() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fps_;
}
inline void SetFPS::_internal_set_fps(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fps_ = value;
}

// -------------------------------------------------------------------

// CancelQText

// -------------------------------------------------------------------

// Move

// uint32 type = 1;
inline void Move::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0u;
}
inline ::uint32_t Move::type() const {
  // @@protoc_insertion_point(field_get:dapi.commands.Move.type)
  return _internal_type();
}
inline void Move::set_type(::uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:dapi.commands.Move.type)
}
inline ::uint32_t Move::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.type_;
}
inline void Move::_internal_set_type(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// uint32 targetX = 2;
inline void Move::clear_targetx() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.targetx_ = 0u;
}
inline ::uint32_t Move::targetx() const {
  // @@protoc_insertion_point(field_get:dapi.commands.Move.targetX)
  return _internal_targetx();
}
inline void Move::set_targetx(::uint32_t value) {
  _internal_set_targetx(value);
  // @@protoc_insertion_point(field_set:dapi.commands.Move.targetX)
}
inline ::uint32_t Move::_internal_targetx() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.targetx_;
}
inline void Move::_internal_set_targetx(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.targetx_ = value;
}

// uint32 targetY = 3;
inline void Move::clear_targety() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.targety_ = 0u;
}
inline ::uint32_t Move::targety() const {
  // @@protoc_insertion_point(field_get:dapi.commands.Move.targetY)
  return _internal_targety();
}
inline void Move::set_targety(::uint32_t value) {
  _internal_set_targety(value);
  // @@protoc_insertion_point(field_set:dapi.commands.Move.targetY)
}
inline ::uint32_t Move::_internal_targety() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.targety_;
}
inline void Move::_internal_set_targety(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.targety_ = value;
}

// -------------------------------------------------------------------

// Talk

// uint32 targetX = 1;
inline void Talk::clear_targetx() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.targetx_ = 0u;
}
inline ::uint32_t Talk::targetx() const {
  // @@protoc_insertion_point(field_get:dapi.commands.Talk.targetX)
  return _internal_targetx();
}
inline void Talk::set_targetx(::uint32_t value) {
  _internal_set_targetx(value);
  // @@protoc_insertion_point(field_set:dapi.commands.Talk.targetX)
}
inline ::uint32_t Talk::_internal_targetx() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.targetx_;
}
inline void Talk::_internal_set_targetx(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.targetx_ = value;
}

// uint32 targetY = 2;
inline void Talk::clear_targety() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.targety_ = 0u;
}
inline ::uint32_t Talk::targety() const {
  // @@protoc_insertion_point(field_get:dapi.commands.Talk.targetY)
  return _internal_targety();
}
inline void Talk::set_targety(::uint32_t value) {
  _internal_set_targety(value);
  // @@protoc_insertion_point(field_set:dapi.commands.Talk.targetY)
}
inline ::uint32_t Talk::_internal_targety() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.targety_;
}
inline void Talk::_internal_set_targety(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.targety_ = value;
}

// -------------------------------------------------------------------

// SelectStoreOption

// uint32 option = 1;
inline void SelectStoreOption::clear_option() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.option_ = 0u;
}
inline ::uint32_t SelectStoreOption::option() const {
  // @@protoc_insertion_point(field_get:dapi.commands.SelectStoreOption.option)
  return _internal_option();
}
inline void SelectStoreOption::set_option(::uint32_t value) {
  _internal_set_option(value);
  // @@protoc_insertion_point(field_set:dapi.commands.SelectStoreOption.option)
}
inline ::uint32_t SelectStoreOption::_internal_option() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.option_;
}
inline void SelectStoreOption::_internal_set_option(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.option_ = value;
}

// -------------------------------------------------------------------

// BuyItem

// uint32 ID = 1;
inline void BuyItem::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = 0u;
}
inline ::uint32_t BuyItem::id() const {
  // @@protoc_insertion_point(field_get:dapi.commands.BuyItem.ID)
  return _internal_id();
}
inline void BuyItem::set_id(::uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:dapi.commands.BuyItem.ID)
}
inline ::uint32_t BuyItem::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void BuyItem::_internal_set_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// -------------------------------------------------------------------

// SellItem

// uint32 ID = 1;
inline void SellItem::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = 0u;
}
inline ::uint32_t SellItem::id() const {
  // @@protoc_insertion_point(field_get:dapi.commands.SellItem.ID)
  return _internal_id();
}
inline void SellItem::set_id(::uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:dapi.commands.SellItem.ID)
}
inline ::uint32_t SellItem::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void SellItem::_internal_set_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// -------------------------------------------------------------------

// RechargeItem

// uint32 ID = 1;
inline void RechargeItem::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = 0u;
}
inline ::uint32_t RechargeItem::id() const {
  // @@protoc_insertion_point(field_get:dapi.commands.RechargeItem.ID)
  return _internal_id();
}
inline void RechargeItem::set_id(::uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:dapi.commands.RechargeItem.ID)
}
inline ::uint32_t RechargeItem::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void RechargeItem::_internal_set_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// -------------------------------------------------------------------

// RepairItem

// uint32 ID = 1;
inline void RepairItem::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = 0u;
}
inline ::uint32_t RepairItem::id() const {
  // @@protoc_insertion_point(field_get:dapi.commands.RepairItem.ID)
  return _internal_id();
}
inline void RepairItem::set_id(::uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:dapi.commands.RepairItem.ID)
}
inline ::uint32_t RepairItem::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void RepairItem::_internal_set_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// -------------------------------------------------------------------

// AttackMonster

// uint32 index = 1;
inline void AttackMonster::clear_index() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.index_ = 0u;
}
inline ::uint32_t AttackMonster::index() const {
  // @@protoc_insertion_point(field_get:dapi.commands.AttackMonster.index)
  return _internal_index();
}
inline void AttackMonster::set_index(::uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:dapi.commands.AttackMonster.index)
}
inline ::uint32_t AttackMonster::_internal_index() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.index_;
}
inline void AttackMonster::_internal_set_index(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.index_ = value;
}

// -------------------------------------------------------------------

// AttackXY

// sint32 x = 1;
inline void AttackXY::clear_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = 0;
}
inline ::int32_t AttackXY::x() const {
  // @@protoc_insertion_point(field_get:dapi.commands.AttackXY.x)
  return _internal_x();
}
inline void AttackXY::set_x(::int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:dapi.commands.AttackXY.x)
}
inline ::int32_t AttackXY::_internal_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.x_;
}
inline void AttackXY::_internal_set_x(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = value;
}

// sint32 y = 2;
inline void AttackXY::clear_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = 0;
}
inline ::int32_t AttackXY::y() const {
  // @@protoc_insertion_point(field_get:dapi.commands.AttackXY.y)
  return _internal_y();
}
inline void AttackXY::set_y(::int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:dapi.commands.AttackXY.y)
}
inline ::int32_t AttackXY::_internal_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.y_;
}
inline void AttackXY::_internal_set_y(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = value;
}

// -------------------------------------------------------------------

// OperateObject

// uint32 index = 1;
inline void OperateObject::clear_index() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.index_ = 0u;
}
inline ::uint32_t OperateObject::index() const {
  // @@protoc_insertion_point(field_get:dapi.commands.OperateObject.index)
  return _internal_index();
}
inline void OperateObject::set_index(::uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:dapi.commands.OperateObject.index)
}
inline ::uint32_t OperateObject::_internal_index() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.index_;
}
inline void OperateObject::_internal_set_index(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.index_ = value;
}

// -------------------------------------------------------------------

// UseBeltItem

// uint32 slot = 1;
inline void UseBeltItem::clear_slot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.slot_ = 0u;
}
inline ::uint32_t UseBeltItem::slot() const {
  // @@protoc_insertion_point(field_get:dapi.commands.UseBeltItem.slot)
  return _internal_slot();
}
inline void UseBeltItem::set_slot(::uint32_t value) {
  _internal_set_slot(value);
  // @@protoc_insertion_point(field_set:dapi.commands.UseBeltItem.slot)
}
inline ::uint32_t UseBeltItem::_internal_slot() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.slot_;
}
inline void UseBeltItem::_internal_set_slot(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.slot_ = value;
}

// -------------------------------------------------------------------

// ToggleCharacterSheet

// -------------------------------------------------------------------

// IncreaseStat

// uint32 stat = 1;
inline void IncreaseStat::clear_stat() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stat_ = 0u;
}
inline ::uint32_t IncreaseStat::stat() const {
  // @@protoc_insertion_point(field_get:dapi.commands.IncreaseStat.stat)
  return _internal_stat();
}
inline void IncreaseStat::set_stat(::uint32_t value) {
  _internal_set_stat(value);
  // @@protoc_insertion_point(field_set:dapi.commands.IncreaseStat.stat)
}
inline ::uint32_t IncreaseStat::_internal_stat() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.stat_;
}
inline void IncreaseStat::_internal_set_stat(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stat_ = value;
}

// -------------------------------------------------------------------

// GetItem

// uint32 ID = 1;
inline void GetItem::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = 0u;
}
inline ::uint32_t GetItem::id() const {
  // @@protoc_insertion_point(field_get:dapi.commands.GetItem.ID)
  return _internal_id();
}
inline void GetItem::set_id(::uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:dapi.commands.GetItem.ID)
}
inline ::uint32_t GetItem::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void GetItem::_internal_set_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// -------------------------------------------------------------------

// SetSpell

// sint32 spellID = 1;
inline void SetSpell::clear_spellid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.spellid_ = 0;
}
inline ::int32_t SetSpell::spellid() const {
  // @@protoc_insertion_point(field_get:dapi.commands.SetSpell.spellID)
  return _internal_spellid();
}
inline void SetSpell::set_spellid(::int32_t value) {
  _internal_set_spellid(value);
  // @@protoc_insertion_point(field_set:dapi.commands.SetSpell.spellID)
}
inline ::int32_t SetSpell::_internal_spellid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.spellid_;
}
inline void SetSpell::_internal_set_spellid(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.spellid_ = value;
}

// sint32 spellType = 2;
inline void SetSpell::clear_spelltype() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.spelltype_ = 0;
}
inline ::int32_t SetSpell::spelltype() const {
  // @@protoc_insertion_point(field_get:dapi.commands.SetSpell.spellType)
  return _internal_spelltype();
}
inline void SetSpell::set_spelltype(::int32_t value) {
  _internal_set_spelltype(value);
  // @@protoc_insertion_point(field_set:dapi.commands.SetSpell.spellType)
}
inline ::int32_t SetSpell::_internal_spelltype() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.spelltype_;
}
inline void SetSpell::_internal_set_spelltype(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.spelltype_ = value;
}

// -------------------------------------------------------------------

// CastMonster

// uint32 index = 1;
inline void CastMonster::clear_index() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.index_ = 0u;
}
inline ::uint32_t CastMonster::index() const {
  // @@protoc_insertion_point(field_get:dapi.commands.CastMonster.index)
  return _internal_index();
}
inline void CastMonster::set_index(::uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:dapi.commands.CastMonster.index)
}
inline ::uint32_t CastMonster::_internal_index() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.index_;
}
inline void CastMonster::_internal_set_index(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.index_ = value;
}

// -------------------------------------------------------------------

// CastXY

// sint32 x = 1;
inline void CastXY::clear_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = 0;
}
inline ::int32_t CastXY::x() const {
  // @@protoc_insertion_point(field_get:dapi.commands.CastXY.x)
  return _internal_x();
}
inline void CastXY::set_x(::int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:dapi.commands.CastXY.x)
}
inline ::int32_t CastXY::_internal_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.x_;
}
inline void CastXY::_internal_set_x(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = value;
}

// sint32 y = 2;
inline void CastXY::clear_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = 0;
}
inline ::int32_t CastXY::y() const {
  // @@protoc_insertion_point(field_get:dapi.commands.CastXY.y)
  return _internal_y();
}
inline void CastXY::set_y(::int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:dapi.commands.CastXY.y)
}
inline ::int32_t CastXY::_internal_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.y_;
}
inline void CastXY::_internal_set_y(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = value;
}

// -------------------------------------------------------------------

// ToggleInventory

// -------------------------------------------------------------------

// PutInCursor

// uint32 ID = 1;
inline void PutInCursor::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = 0u;
}
inline ::uint32_t PutInCursor::id() const {
  // @@protoc_insertion_point(field_get:dapi.commands.PutInCursor.ID)
  return _internal_id();
}
inline void PutInCursor::set_id(::uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:dapi.commands.PutInCursor.ID)
}
inline ::uint32_t PutInCursor::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void PutInCursor::_internal_set_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// -------------------------------------------------------------------

// PutCursorItem

// sint32 target = 1;
inline void PutCursorItem::clear_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_ = 0;
}
inline ::int32_t PutCursorItem::target() const {
  // @@protoc_insertion_point(field_get:dapi.commands.PutCursorItem.target)
  return _internal_target();
}
inline void PutCursorItem::set_target(::int32_t value) {
  _internal_set_target(value);
  // @@protoc_insertion_point(field_set:dapi.commands.PutCursorItem.target)
}
inline ::int32_t PutCursorItem::_internal_target() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.target_;
}
inline void PutCursorItem::_internal_set_target(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.target_ = value;
}

// -------------------------------------------------------------------

// DropCursorItem

// -------------------------------------------------------------------

// UseItem

// uint32 ID = 1;
inline void UseItem::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = 0u;
}
inline ::uint32_t UseItem::id() const {
  // @@protoc_insertion_point(field_get:dapi.commands.UseItem.ID)
  return _internal_id();
}
inline void UseItem::set_id(::uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:dapi.commands.UseItem.ID)
}
inline ::uint32_t UseItem::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void UseItem::_internal_set_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// -------------------------------------------------------------------

// IdentifyStoreItem

// uint32 ID = 1;
inline void IdentifyStoreItem::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = 0u;
}
inline ::uint32_t IdentifyStoreItem::id() const {
  // @@protoc_insertion_point(field_get:dapi.commands.IdentifyStoreItem.ID)
  return _internal_id();
}
inline void IdentifyStoreItem::set_id(::uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:dapi.commands.IdentifyStoreItem.ID)
}
inline ::uint32_t IdentifyStoreItem::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void IdentifyStoreItem::_internal_set_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// -------------------------------------------------------------------

// DisarmTrap

// uint32 index = 1;
inline void DisarmTrap::clear_index() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.index_ = 0u;
}
inline ::uint32_t DisarmTrap::index() const {
  // @@protoc_insertion_point(field_get:dapi.commands.DisarmTrap.index)
  return _internal_index();
}
inline void DisarmTrap::set_index(::uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:dapi.commands.DisarmTrap.index)
}
inline ::uint32_t DisarmTrap::_internal_index() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.index_;
}
inline void DisarmTrap::_internal_set_index(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.index_ = value;
}

// -------------------------------------------------------------------

// SkillRepair

// uint32 ID = 1;
inline void SkillRepair::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = 0u;
}
inline ::uint32_t SkillRepair::id() const {
  // @@protoc_insertion_point(field_get:dapi.commands.SkillRepair.ID)
  return _internal_id();
}
inline void SkillRepair::set_id(::uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:dapi.commands.SkillRepair.ID)
}
inline ::uint32_t SkillRepair::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void SkillRepair::_internal_set_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// -------------------------------------------------------------------

// SkillRecharge

// uint32 ID = 1;
inline void SkillRecharge::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = 0u;
}
inline ::uint32_t SkillRecharge::id() const {
  // @@protoc_insertion_point(field_get:dapi.commands.SkillRecharge.ID)
  return _internal_id();
}
inline void SkillRecharge::set_id(::uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:dapi.commands.SkillRecharge.ID)
}
inline ::uint32_t SkillRecharge::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void SkillRecharge::_internal_set_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// -------------------------------------------------------------------

// ToggleMenu

// -------------------------------------------------------------------

// SaveGame

// -------------------------------------------------------------------

// Quit

// -------------------------------------------------------------------

// ClearCursor

// -------------------------------------------------------------------

// IdentifyItem

// uint32 ID = 1;
inline void IdentifyItem::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = 0u;
}
inline ::uint32_t IdentifyItem::id() const {
  // @@protoc_insertion_point(field_get:dapi.commands.IdentifyItem.ID)
  return _internal_id();
}
inline void IdentifyItem::set_id(::uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:dapi.commands.IdentifyItem.ID)
}
inline ::uint32_t IdentifyItem::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void IdentifyItem::_internal_set_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// -------------------------------------------------------------------

// Command

// .dapi.commands.Move move = 1;
inline bool Command::has_move() const {
  return command_case() == kMove;
}
inline bool Command::_internal_has_move() const {
  return command_case() == kMove;
}
inline void Command::set_has_move() {
  _impl_._oneof_case_[0] = kMove;
}
inline void Command::clear_move() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (command_case() == kMove) {
    if (GetArena() == nullptr) {
      delete _impl_.command_.move_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      if (_impl_.command_.move_ != nullptr) {
        _impl_.command_.move_->Clear();
      }
    }
    clear_has_command();
  }
}
inline ::dapi::commands::Move* Command::release_move() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.move)
  if (command_case() == kMove) {
    clear_has_command();
    auto* temp = _impl_.command_.move_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.move_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dapi::commands::Move& Command::_internal_move() const {
  return command_case() == kMove ? *_impl_.command_.move_ : reinterpret_cast<::dapi::commands::Move&>(::dapi::commands::_Move_default_instance_);
}
inline const ::dapi::commands::Move& Command::move() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.move)
  return _internal_move();
}
inline ::dapi::commands::Move* Command::unsafe_arena_release_move() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dapi.commands.Command.move)
  if (command_case() == kMove) {
    clear_has_command();
    auto* temp = _impl_.command_.move_;
    _impl_.command_.move_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_move(::dapi::commands::Move* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_command();
  if (value) {
    set_has_move();
    _impl_.command_.move_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dapi.commands.Command.move)
}
inline ::dapi::commands::Move* Command::_internal_mutable_move() {
  if (command_case() != kMove) {
    clear_command();
    set_has_move();
    _impl_.command_.move_ =
        ::google::protobuf::MessageLite::DefaultConstruct<::dapi::commands::Move>(GetArena());
  }
  return _impl_.command_.move_;
}
inline ::dapi::commands::Move* Command::mutable_move() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dapi::commands::Move* _msg = _internal_mutable_move();
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.move)
  return _msg;
}

// .dapi.commands.Talk talk = 2;
inline bool Command::has_talk() const {
  return command_case() == kTalk;
}
inline bool Command::_internal_has_talk() const {
  return command_case() == kTalk;
}
inline void Command::set_has_talk() {
  _impl_._oneof_case_[0] = kTalk;
}
inline void Command::clear_talk() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (command_case() == kTalk) {
    if (GetArena() == nullptr) {
      delete _impl_.command_.talk_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      if (_impl_.command_.talk_ != nullptr) {
        _impl_.command_.talk_->Clear();
      }
    }
    clear_has_command();
  }
}
inline ::dapi::commands::Talk* Command::release_talk() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.talk)
  if (command_case() == kTalk) {
    clear_has_command();
    auto* temp = _impl_.command_.talk_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.talk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dapi::commands::Talk& Command::_internal_talk() const {
  return command_case() == kTalk ? *_impl_.command_.talk_ : reinterpret_cast<::dapi::commands::Talk&>(::dapi::commands::_Talk_default_instance_);
}
inline const ::dapi::commands::Talk& Command::talk() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.talk)
  return _internal_talk();
}
inline ::dapi::commands::Talk* Command::unsafe_arena_release_talk() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dapi.commands.Command.talk)
  if (command_case() == kTalk) {
    clear_has_command();
    auto* temp = _impl_.command_.talk_;
    _impl_.command_.talk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_talk(::dapi::commands::Talk* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_command();
  if (value) {
    set_has_talk();
    _impl_.command_.talk_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dapi.commands.Command.talk)
}
inline ::dapi::commands::Talk* Command::_internal_mutable_talk() {
  if (command_case() != kTalk) {
    clear_command();
    set_has_talk();
    _impl_.command_.talk_ =
        ::google::protobuf::MessageLite::DefaultConstruct<::dapi::commands::Talk>(GetArena());
  }
  return _impl_.command_.talk_;
}
inline ::dapi::commands::Talk* Command::mutable_talk() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dapi::commands::Talk* _msg = _internal_mutable_talk();
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.talk)
  return _msg;
}

// .dapi.commands.SelectStoreOption option = 3;
inline bool Command::has_option() const {
  return command_case() == kOption;
}
inline bool Command::_internal_has_option() const {
  return command_case() == kOption;
}
inline void Command::set_has_option() {
  _impl_._oneof_case_[0] = kOption;
}
inline void Command::clear_option() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (command_case() == kOption) {
    if (GetArena() == nullptr) {
      delete _impl_.command_.option_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      if (_impl_.command_.option_ != nullptr) {
        _impl_.command_.option_->Clear();
      }
    }
    clear_has_command();
  }
}
inline ::dapi::commands::SelectStoreOption* Command::release_option() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.option)
  if (command_case() == kOption) {
    clear_has_command();
    auto* temp = _impl_.command_.option_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.option_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dapi::commands::SelectStoreOption& Command::_internal_option() const {
  return command_case() == kOption ? *_impl_.command_.option_ : reinterpret_cast<::dapi::commands::SelectStoreOption&>(::dapi::commands::_SelectStoreOption_default_instance_);
}
inline const ::dapi::commands::SelectStoreOption& Command::option() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.option)
  return _internal_option();
}
inline ::dapi::commands::SelectStoreOption* Command::unsafe_arena_release_option() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dapi.commands.Command.option)
  if (command_case() == kOption) {
    clear_has_command();
    auto* temp = _impl_.command_.option_;
    _impl_.command_.option_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_option(::dapi::commands::SelectStoreOption* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_command();
  if (value) {
    set_has_option();
    _impl_.command_.option_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dapi.commands.Command.option)
}
inline ::dapi::commands::SelectStoreOption* Command::_internal_mutable_option() {
  if (command_case() != kOption) {
    clear_command();
    set_has_option();
    _impl_.command_.option_ =
        ::google::protobuf::MessageLite::DefaultConstruct<::dapi::commands::SelectStoreOption>(GetArena());
  }
  return _impl_.command_.option_;
}
inline ::dapi::commands::SelectStoreOption* Command::mutable_option() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dapi::commands::SelectStoreOption* _msg = _internal_mutable_option();
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.option)
  return _msg;
}

// .dapi.commands.BuyItem buyItem = 4;
inline bool Command::has_buyitem() const {
  return command_case() == kBuyItem;
}
inline bool Command::_internal_has_buyitem() const {
  return command_case() == kBuyItem;
}
inline void Command::set_has_buyitem() {
  _impl_._oneof_case_[0] = kBuyItem;
}
inline void Command::clear_buyitem() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (command_case() == kBuyItem) {
    if (GetArena() == nullptr) {
      delete _impl_.command_.buyitem_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      if (_impl_.command_.buyitem_ != nullptr) {
        _impl_.command_.buyitem_->Clear();
      }
    }
    clear_has_command();
  }
}
inline ::dapi::commands::BuyItem* Command::release_buyitem() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.buyItem)
  if (command_case() == kBuyItem) {
    clear_has_command();
    auto* temp = _impl_.command_.buyitem_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.buyitem_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dapi::commands::BuyItem& Command::_internal_buyitem() const {
  return command_case() == kBuyItem ? *_impl_.command_.buyitem_ : reinterpret_cast<::dapi::commands::BuyItem&>(::dapi::commands::_BuyItem_default_instance_);
}
inline const ::dapi::commands::BuyItem& Command::buyitem() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.buyItem)
  return _internal_buyitem();
}
inline ::dapi::commands::BuyItem* Command::unsafe_arena_release_buyitem() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dapi.commands.Command.buyItem)
  if (command_case() == kBuyItem) {
    clear_has_command();
    auto* temp = _impl_.command_.buyitem_;
    _impl_.command_.buyitem_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_buyitem(::dapi::commands::BuyItem* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_command();
  if (value) {
    set_has_buyitem();
    _impl_.command_.buyitem_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dapi.commands.Command.buyItem)
}
inline ::dapi::commands::BuyItem* Command::_internal_mutable_buyitem() {
  if (command_case() != kBuyItem) {
    clear_command();
    set_has_buyitem();
    _impl_.command_.buyitem_ =
        ::google::protobuf::MessageLite::DefaultConstruct<::dapi::commands::BuyItem>(GetArena());
  }
  return _impl_.command_.buyitem_;
}
inline ::dapi::commands::BuyItem* Command::mutable_buyitem() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dapi::commands::BuyItem* _msg = _internal_mutable_buyitem();
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.buyItem)
  return _msg;
}

// .dapi.commands.SellItem sellItem = 5;
inline bool Command::has_sellitem() const {
  return command_case() == kSellItem;
}
inline bool Command::_internal_has_sellitem() const {
  return command_case() == kSellItem;
}
inline void Command::set_has_sellitem() {
  _impl_._oneof_case_[0] = kSellItem;
}
inline void Command::clear_sellitem() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (command_case() == kSellItem) {
    if (GetArena() == nullptr) {
      delete _impl_.command_.sellitem_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      if (_impl_.command_.sellitem_ != nullptr) {
        _impl_.command_.sellitem_->Clear();
      }
    }
    clear_has_command();
  }
}
inline ::dapi::commands::SellItem* Command::release_sellitem() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.sellItem)
  if (command_case() == kSellItem) {
    clear_has_command();
    auto* temp = _impl_.command_.sellitem_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.sellitem_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dapi::commands::SellItem& Command::_internal_sellitem() const {
  return command_case() == kSellItem ? *_impl_.command_.sellitem_ : reinterpret_cast<::dapi::commands::SellItem&>(::dapi::commands::_SellItem_default_instance_);
}
inline const ::dapi::commands::SellItem& Command::sellitem() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.sellItem)
  return _internal_sellitem();
}
inline ::dapi::commands::SellItem* Command::unsafe_arena_release_sellitem() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dapi.commands.Command.sellItem)
  if (command_case() == kSellItem) {
    clear_has_command();
    auto* temp = _impl_.command_.sellitem_;
    _impl_.command_.sellitem_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_sellitem(::dapi::commands::SellItem* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_command();
  if (value) {
    set_has_sellitem();
    _impl_.command_.sellitem_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dapi.commands.Command.sellItem)
}
inline ::dapi::commands::SellItem* Command::_internal_mutable_sellitem() {
  if (command_case() != kSellItem) {
    clear_command();
    set_has_sellitem();
    _impl_.command_.sellitem_ =
        ::google::protobuf::MessageLite::DefaultConstruct<::dapi::commands::SellItem>(GetArena());
  }
  return _impl_.command_.sellitem_;
}
inline ::dapi::commands::SellItem* Command::mutable_sellitem() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dapi::commands::SellItem* _msg = _internal_mutable_sellitem();
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.sellItem)
  return _msg;
}

// .dapi.commands.RechargeItem rechargeItem = 6;
inline bool Command::has_rechargeitem() const {
  return command_case() == kRechargeItem;
}
inline bool Command::_internal_has_rechargeitem() const {
  return command_case() == kRechargeItem;
}
inline void Command::set_has_rechargeitem() {
  _impl_._oneof_case_[0] = kRechargeItem;
}
inline void Command::clear_rechargeitem() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (command_case() == kRechargeItem) {
    if (GetArena() == nullptr) {
      delete _impl_.command_.rechargeitem_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      if (_impl_.command_.rechargeitem_ != nullptr) {
        _impl_.command_.rechargeitem_->Clear();
      }
    }
    clear_has_command();
  }
}
inline ::dapi::commands::RechargeItem* Command::release_rechargeitem() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.rechargeItem)
  if (command_case() == kRechargeItem) {
    clear_has_command();
    auto* temp = _impl_.command_.rechargeitem_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.rechargeitem_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dapi::commands::RechargeItem& Command::_internal_rechargeitem() const {
  return command_case() == kRechargeItem ? *_impl_.command_.rechargeitem_ : reinterpret_cast<::dapi::commands::RechargeItem&>(::dapi::commands::_RechargeItem_default_instance_);
}
inline const ::dapi::commands::RechargeItem& Command::rechargeitem() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.rechargeItem)
  return _internal_rechargeitem();
}
inline ::dapi::commands::RechargeItem* Command::unsafe_arena_release_rechargeitem() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dapi.commands.Command.rechargeItem)
  if (command_case() == kRechargeItem) {
    clear_has_command();
    auto* temp = _impl_.command_.rechargeitem_;
    _impl_.command_.rechargeitem_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_rechargeitem(::dapi::commands::RechargeItem* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_command();
  if (value) {
    set_has_rechargeitem();
    _impl_.command_.rechargeitem_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dapi.commands.Command.rechargeItem)
}
inline ::dapi::commands::RechargeItem* Command::_internal_mutable_rechargeitem() {
  if (command_case() != kRechargeItem) {
    clear_command();
    set_has_rechargeitem();
    _impl_.command_.rechargeitem_ =
        ::google::protobuf::MessageLite::DefaultConstruct<::dapi::commands::RechargeItem>(GetArena());
  }
  return _impl_.command_.rechargeitem_;
}
inline ::dapi::commands::RechargeItem* Command::mutable_rechargeitem() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dapi::commands::RechargeItem* _msg = _internal_mutable_rechargeitem();
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.rechargeItem)
  return _msg;
}

// .dapi.commands.RepairItem repairItem = 7;
inline bool Command::has_repairitem() const {
  return command_case() == kRepairItem;
}
inline bool Command::_internal_has_repairitem() const {
  return command_case() == kRepairItem;
}
inline void Command::set_has_repairitem() {
  _impl_._oneof_case_[0] = kRepairItem;
}
inline void Command::clear_repairitem() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (command_case() == kRepairItem) {
    if (GetArena() == nullptr) {
      delete _impl_.command_.repairitem_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      if (_impl_.command_.repairitem_ != nullptr) {
        _impl_.command_.repairitem_->Clear();
      }
    }
    clear_has_command();
  }
}
inline ::dapi::commands::RepairItem* Command::release_repairitem() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.repairItem)
  if (command_case() == kRepairItem) {
    clear_has_command();
    auto* temp = _impl_.command_.repairitem_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.repairitem_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dapi::commands::RepairItem& Command::_internal_repairitem() const {
  return command_case() == kRepairItem ? *_impl_.command_.repairitem_ : reinterpret_cast<::dapi::commands::RepairItem&>(::dapi::commands::_RepairItem_default_instance_);
}
inline const ::dapi::commands::RepairItem& Command::repairitem() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.repairItem)
  return _internal_repairitem();
}
inline ::dapi::commands::RepairItem* Command::unsafe_arena_release_repairitem() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dapi.commands.Command.repairItem)
  if (command_case() == kRepairItem) {
    clear_has_command();
    auto* temp = _impl_.command_.repairitem_;
    _impl_.command_.repairitem_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_repairitem(::dapi::commands::RepairItem* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_command();
  if (value) {
    set_has_repairitem();
    _impl_.command_.repairitem_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dapi.commands.Command.repairItem)
}
inline ::dapi::commands::RepairItem* Command::_internal_mutable_repairitem() {
  if (command_case() != kRepairItem) {
    clear_command();
    set_has_repairitem();
    _impl_.command_.repairitem_ =
        ::google::protobuf::MessageLite::DefaultConstruct<::dapi::commands::RepairItem>(GetArena());
  }
  return _impl_.command_.repairitem_;
}
inline ::dapi::commands::RepairItem* Command::mutable_repairitem() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dapi::commands::RepairItem* _msg = _internal_mutable_repairitem();
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.repairItem)
  return _msg;
}

// .dapi.commands.AttackMonster attackMonster = 8;
inline bool Command::has_attackmonster() const {
  return command_case() == kAttackMonster;
}
inline bool Command::_internal_has_attackmonster() const {
  return command_case() == kAttackMonster;
}
inline void Command::set_has_attackmonster() {
  _impl_._oneof_case_[0] = kAttackMonster;
}
inline void Command::clear_attackmonster() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (command_case() == kAttackMonster) {
    if (GetArena() == nullptr) {
      delete _impl_.command_.attackmonster_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      if (_impl_.command_.attackmonster_ != nullptr) {
        _impl_.command_.attackmonster_->Clear();
      }
    }
    clear_has_command();
  }
}
inline ::dapi::commands::AttackMonster* Command::release_attackmonster() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.attackMonster)
  if (command_case() == kAttackMonster) {
    clear_has_command();
    auto* temp = _impl_.command_.attackmonster_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.attackmonster_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dapi::commands::AttackMonster& Command::_internal_attackmonster() const {
  return command_case() == kAttackMonster ? *_impl_.command_.attackmonster_ : reinterpret_cast<::dapi::commands::AttackMonster&>(::dapi::commands::_AttackMonster_default_instance_);
}
inline const ::dapi::commands::AttackMonster& Command::attackmonster() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.attackMonster)
  return _internal_attackmonster();
}
inline ::dapi::commands::AttackMonster* Command::unsafe_arena_release_attackmonster() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dapi.commands.Command.attackMonster)
  if (command_case() == kAttackMonster) {
    clear_has_command();
    auto* temp = _impl_.command_.attackmonster_;
    _impl_.command_.attackmonster_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_attackmonster(::dapi::commands::AttackMonster* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_command();
  if (value) {
    set_has_attackmonster();
    _impl_.command_.attackmonster_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dapi.commands.Command.attackMonster)
}
inline ::dapi::commands::AttackMonster* Command::_internal_mutable_attackmonster() {
  if (command_case() != kAttackMonster) {
    clear_command();
    set_has_attackmonster();
    _impl_.command_.attackmonster_ =
        ::google::protobuf::MessageLite::DefaultConstruct<::dapi::commands::AttackMonster>(GetArena());
  }
  return _impl_.command_.attackmonster_;
}
inline ::dapi::commands::AttackMonster* Command::mutable_attackmonster() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dapi::commands::AttackMonster* _msg = _internal_mutable_attackmonster();
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.attackMonster)
  return _msg;
}

// .dapi.commands.AttackXY attackXY = 9;
inline bool Command::has_attackxy() const {
  return command_case() == kAttackXY;
}
inline bool Command::_internal_has_attackxy() const {
  return command_case() == kAttackXY;
}
inline void Command::set_has_attackxy() {
  _impl_._oneof_case_[0] = kAttackXY;
}
inline void Command::clear_attackxy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (command_case() == kAttackXY) {
    if (GetArena() == nullptr) {
      delete _impl_.command_.attackxy_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      if (_impl_.command_.attackxy_ != nullptr) {
        _impl_.command_.attackxy_->Clear();
      }
    }
    clear_has_command();
  }
}
inline ::dapi::commands::AttackXY* Command::release_attackxy() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.attackXY)
  if (command_case() == kAttackXY) {
    clear_has_command();
    auto* temp = _impl_.command_.attackxy_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.attackxy_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dapi::commands::AttackXY& Command::_internal_attackxy() const {
  return command_case() == kAttackXY ? *_impl_.command_.attackxy_ : reinterpret_cast<::dapi::commands::AttackXY&>(::dapi::commands::_AttackXY_default_instance_);
}
inline const ::dapi::commands::AttackXY& Command::attackxy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.attackXY)
  return _internal_attackxy();
}
inline ::dapi::commands::AttackXY* Command::unsafe_arena_release_attackxy() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dapi.commands.Command.attackXY)
  if (command_case() == kAttackXY) {
    clear_has_command();
    auto* temp = _impl_.command_.attackxy_;
    _impl_.command_.attackxy_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_attackxy(::dapi::commands::AttackXY* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_command();
  if (value) {
    set_has_attackxy();
    _impl_.command_.attackxy_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dapi.commands.Command.attackXY)
}
inline ::dapi::commands::AttackXY* Command::_internal_mutable_attackxy() {
  if (command_case() != kAttackXY) {
    clear_command();
    set_has_attackxy();
    _impl_.command_.attackxy_ =
        ::google::protobuf::MessageLite::DefaultConstruct<::dapi::commands::AttackXY>(GetArena());
  }
  return _impl_.command_.attackxy_;
}
inline ::dapi::commands::AttackXY* Command::mutable_attackxy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dapi::commands::AttackXY* _msg = _internal_mutable_attackxy();
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.attackXY)
  return _msg;
}

// .dapi.commands.OperateObject operateObject = 10;
inline bool Command::has_operateobject() const {
  return command_case() == kOperateObject;
}
inline bool Command::_internal_has_operateobject() const {
  return command_case() == kOperateObject;
}
inline void Command::set_has_operateobject() {
  _impl_._oneof_case_[0] = kOperateObject;
}
inline void Command::clear_operateobject() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (command_case() == kOperateObject) {
    if (GetArena() == nullptr) {
      delete _impl_.command_.operateobject_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      if (_impl_.command_.operateobject_ != nullptr) {
        _impl_.command_.operateobject_->Clear();
      }
    }
    clear_has_command();
  }
}
inline ::dapi::commands::OperateObject* Command::release_operateobject() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.operateObject)
  if (command_case() == kOperateObject) {
    clear_has_command();
    auto* temp = _impl_.command_.operateobject_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.operateobject_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dapi::commands::OperateObject& Command::_internal_operateobject() const {
  return command_case() == kOperateObject ? *_impl_.command_.operateobject_ : reinterpret_cast<::dapi::commands::OperateObject&>(::dapi::commands::_OperateObject_default_instance_);
}
inline const ::dapi::commands::OperateObject& Command::operateobject() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.operateObject)
  return _internal_operateobject();
}
inline ::dapi::commands::OperateObject* Command::unsafe_arena_release_operateobject() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dapi.commands.Command.operateObject)
  if (command_case() == kOperateObject) {
    clear_has_command();
    auto* temp = _impl_.command_.operateobject_;
    _impl_.command_.operateobject_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_operateobject(::dapi::commands::OperateObject* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_command();
  if (value) {
    set_has_operateobject();
    _impl_.command_.operateobject_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dapi.commands.Command.operateObject)
}
inline ::dapi::commands::OperateObject* Command::_internal_mutable_operateobject() {
  if (command_case() != kOperateObject) {
    clear_command();
    set_has_operateobject();
    _impl_.command_.operateobject_ =
        ::google::protobuf::MessageLite::DefaultConstruct<::dapi::commands::OperateObject>(GetArena());
  }
  return _impl_.command_.operateobject_;
}
inline ::dapi::commands::OperateObject* Command::mutable_operateobject() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dapi::commands::OperateObject* _msg = _internal_mutable_operateobject();
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.operateObject)
  return _msg;
}

// .dapi.commands.UseBeltItem useBeltItem = 11;
inline bool Command::has_usebeltitem() const {
  return command_case() == kUseBeltItem;
}
inline bool Command::_internal_has_usebeltitem() const {
  return command_case() == kUseBeltItem;
}
inline void Command::set_has_usebeltitem() {
  _impl_._oneof_case_[0] = kUseBeltItem;
}
inline void Command::clear_usebeltitem() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (command_case() == kUseBeltItem) {
    if (GetArena() == nullptr) {
      delete _impl_.command_.usebeltitem_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      if (_impl_.command_.usebeltitem_ != nullptr) {
        _impl_.command_.usebeltitem_->Clear();
      }
    }
    clear_has_command();
  }
}
inline ::dapi::commands::UseBeltItem* Command::release_usebeltitem() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.useBeltItem)
  if (command_case() == kUseBeltItem) {
    clear_has_command();
    auto* temp = _impl_.command_.usebeltitem_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.usebeltitem_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dapi::commands::UseBeltItem& Command::_internal_usebeltitem() const {
  return command_case() == kUseBeltItem ? *_impl_.command_.usebeltitem_ : reinterpret_cast<::dapi::commands::UseBeltItem&>(::dapi::commands::_UseBeltItem_default_instance_);
}
inline const ::dapi::commands::UseBeltItem& Command::usebeltitem() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.useBeltItem)
  return _internal_usebeltitem();
}
inline ::dapi::commands::UseBeltItem* Command::unsafe_arena_release_usebeltitem() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dapi.commands.Command.useBeltItem)
  if (command_case() == kUseBeltItem) {
    clear_has_command();
    auto* temp = _impl_.command_.usebeltitem_;
    _impl_.command_.usebeltitem_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_usebeltitem(::dapi::commands::UseBeltItem* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_command();
  if (value) {
    set_has_usebeltitem();
    _impl_.command_.usebeltitem_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dapi.commands.Command.useBeltItem)
}
inline ::dapi::commands::UseBeltItem* Command::_internal_mutable_usebeltitem() {
  if (command_case() != kUseBeltItem) {
    clear_command();
    set_has_usebeltitem();
    _impl_.command_.usebeltitem_ =
        ::google::protobuf::MessageLite::DefaultConstruct<::dapi::commands::UseBeltItem>(GetArena());
  }
  return _impl_.command_.usebeltitem_;
}
inline ::dapi::commands::UseBeltItem* Command::mutable_usebeltitem() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dapi::commands::UseBeltItem* _msg = _internal_mutable_usebeltitem();
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.useBeltItem)
  return _msg;
}

// .dapi.commands.ToggleCharacterSheet toggleCharacterSheet = 12;
inline bool Command::has_togglecharactersheet() const {
  return command_case() == kToggleCharacterSheet;
}
inline bool Command::_internal_has_togglecharactersheet() const {
  return command_case() == kToggleCharacterSheet;
}
inline void Command::set_has_togglecharactersheet() {
  _impl_._oneof_case_[0] = kToggleCharacterSheet;
}
inline void Command::clear_togglecharactersheet() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (command_case() == kToggleCharacterSheet) {
    if (GetArena() == nullptr) {
      delete _impl_.command_.togglecharactersheet_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      if (_impl_.command_.togglecharactersheet_ != nullptr) {
        _impl_.command_.togglecharactersheet_->Clear();
      }
    }
    clear_has_command();
  }
}
inline ::dapi::commands::ToggleCharacterSheet* Command::release_togglecharactersheet() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.toggleCharacterSheet)
  if (command_case() == kToggleCharacterSheet) {
    clear_has_command();
    auto* temp = _impl_.command_.togglecharactersheet_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.togglecharactersheet_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dapi::commands::ToggleCharacterSheet& Command::_internal_togglecharactersheet() const {
  return command_case() == kToggleCharacterSheet ? *_impl_.command_.togglecharactersheet_ : reinterpret_cast<::dapi::commands::ToggleCharacterSheet&>(::dapi::commands::_ToggleCharacterSheet_default_instance_);
}
inline const ::dapi::commands::ToggleCharacterSheet& Command::togglecharactersheet() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.toggleCharacterSheet)
  return _internal_togglecharactersheet();
}
inline ::dapi::commands::ToggleCharacterSheet* Command::unsafe_arena_release_togglecharactersheet() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dapi.commands.Command.toggleCharacterSheet)
  if (command_case() == kToggleCharacterSheet) {
    clear_has_command();
    auto* temp = _impl_.command_.togglecharactersheet_;
    _impl_.command_.togglecharactersheet_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_togglecharactersheet(::dapi::commands::ToggleCharacterSheet* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_command();
  if (value) {
    set_has_togglecharactersheet();
    _impl_.command_.togglecharactersheet_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dapi.commands.Command.toggleCharacterSheet)
}
inline ::dapi::commands::ToggleCharacterSheet* Command::_internal_mutable_togglecharactersheet() {
  if (command_case() != kToggleCharacterSheet) {
    clear_command();
    set_has_togglecharactersheet();
    _impl_.command_.togglecharactersheet_ =
        ::google::protobuf::MessageLite::DefaultConstruct<::dapi::commands::ToggleCharacterSheet>(GetArena());
  }
  return _impl_.command_.togglecharactersheet_;
}
inline ::dapi::commands::ToggleCharacterSheet* Command::mutable_togglecharactersheet() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dapi::commands::ToggleCharacterSheet* _msg = _internal_mutable_togglecharactersheet();
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.toggleCharacterSheet)
  return _msg;
}

// .dapi.commands.IncreaseStat increaseStat = 13;
inline bool Command::has_increasestat() const {
  return command_case() == kIncreaseStat;
}
inline bool Command::_internal_has_increasestat() const {
  return command_case() == kIncreaseStat;
}
inline void Command::set_has_increasestat() {
  _impl_._oneof_case_[0] = kIncreaseStat;
}
inline void Command::clear_increasestat() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (command_case() == kIncreaseStat) {
    if (GetArena() == nullptr) {
      delete _impl_.command_.increasestat_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      if (_impl_.command_.increasestat_ != nullptr) {
        _impl_.command_.increasestat_->Clear();
      }
    }
    clear_has_command();
  }
}
inline ::dapi::commands::IncreaseStat* Command::release_increasestat() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.increaseStat)
  if (command_case() == kIncreaseStat) {
    clear_has_command();
    auto* temp = _impl_.command_.increasestat_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.increasestat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dapi::commands::IncreaseStat& Command::_internal_increasestat() const {
  return command_case() == kIncreaseStat ? *_impl_.command_.increasestat_ : reinterpret_cast<::dapi::commands::IncreaseStat&>(::dapi::commands::_IncreaseStat_default_instance_);
}
inline const ::dapi::commands::IncreaseStat& Command::increasestat() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.increaseStat)
  return _internal_increasestat();
}
inline ::dapi::commands::IncreaseStat* Command::unsafe_arena_release_increasestat() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dapi.commands.Command.increaseStat)
  if (command_case() == kIncreaseStat) {
    clear_has_command();
    auto* temp = _impl_.command_.increasestat_;
    _impl_.command_.increasestat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_increasestat(::dapi::commands::IncreaseStat* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_command();
  if (value) {
    set_has_increasestat();
    _impl_.command_.increasestat_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dapi.commands.Command.increaseStat)
}
inline ::dapi::commands::IncreaseStat* Command::_internal_mutable_increasestat() {
  if (command_case() != kIncreaseStat) {
    clear_command();
    set_has_increasestat();
    _impl_.command_.increasestat_ =
        ::google::protobuf::MessageLite::DefaultConstruct<::dapi::commands::IncreaseStat>(GetArena());
  }
  return _impl_.command_.increasestat_;
}
inline ::dapi::commands::IncreaseStat* Command::mutable_increasestat() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dapi::commands::IncreaseStat* _msg = _internal_mutable_increasestat();
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.increaseStat)
  return _msg;
}

// .dapi.commands.GetItem getItem = 14;
inline bool Command::has_getitem() const {
  return command_case() == kGetItem;
}
inline bool Command::_internal_has_getitem() const {
  return command_case() == kGetItem;
}
inline void Command::set_has_getitem() {
  _impl_._oneof_case_[0] = kGetItem;
}
inline void Command::clear_getitem() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (command_case() == kGetItem) {
    if (GetArena() == nullptr) {
      delete _impl_.command_.getitem_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      if (_impl_.command_.getitem_ != nullptr) {
        _impl_.command_.getitem_->Clear();
      }
    }
    clear_has_command();
  }
}
inline ::dapi::commands::GetItem* Command::release_getitem() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.getItem)
  if (command_case() == kGetItem) {
    clear_has_command();
    auto* temp = _impl_.command_.getitem_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.getitem_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dapi::commands::GetItem& Command::_internal_getitem() const {
  return command_case() == kGetItem ? *_impl_.command_.getitem_ : reinterpret_cast<::dapi::commands::GetItem&>(::dapi::commands::_GetItem_default_instance_);
}
inline const ::dapi::commands::GetItem& Command::getitem() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.getItem)
  return _internal_getitem();
}
inline ::dapi::commands::GetItem* Command::unsafe_arena_release_getitem() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dapi.commands.Command.getItem)
  if (command_case() == kGetItem) {
    clear_has_command();
    auto* temp = _impl_.command_.getitem_;
    _impl_.command_.getitem_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_getitem(::dapi::commands::GetItem* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_command();
  if (value) {
    set_has_getitem();
    _impl_.command_.getitem_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dapi.commands.Command.getItem)
}
inline ::dapi::commands::GetItem* Command::_internal_mutable_getitem() {
  if (command_case() != kGetItem) {
    clear_command();
    set_has_getitem();
    _impl_.command_.getitem_ =
        ::google::protobuf::MessageLite::DefaultConstruct<::dapi::commands::GetItem>(GetArena());
  }
  return _impl_.command_.getitem_;
}
inline ::dapi::commands::GetItem* Command::mutable_getitem() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dapi::commands::GetItem* _msg = _internal_mutable_getitem();
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.getItem)
  return _msg;
}

// .dapi.commands.SetSpell setSpell = 15;
inline bool Command::has_setspell() const {
  return command_case() == kSetSpell;
}
inline bool Command::_internal_has_setspell() const {
  return command_case() == kSetSpell;
}
inline void Command::set_has_setspell() {
  _impl_._oneof_case_[0] = kSetSpell;
}
inline void Command::clear_setspell() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (command_case() == kSetSpell) {
    if (GetArena() == nullptr) {
      delete _impl_.command_.setspell_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      if (_impl_.command_.setspell_ != nullptr) {
        _impl_.command_.setspell_->Clear();
      }
    }
    clear_has_command();
  }
}
inline ::dapi::commands::SetSpell* Command::release_setspell() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.setSpell)
  if (command_case() == kSetSpell) {
    clear_has_command();
    auto* temp = _impl_.command_.setspell_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.setspell_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dapi::commands::SetSpell& Command::_internal_setspell() const {
  return command_case() == kSetSpell ? *_impl_.command_.setspell_ : reinterpret_cast<::dapi::commands::SetSpell&>(::dapi::commands::_SetSpell_default_instance_);
}
inline const ::dapi::commands::SetSpell& Command::setspell() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.setSpell)
  return _internal_setspell();
}
inline ::dapi::commands::SetSpell* Command::unsafe_arena_release_setspell() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dapi.commands.Command.setSpell)
  if (command_case() == kSetSpell) {
    clear_has_command();
    auto* temp = _impl_.command_.setspell_;
    _impl_.command_.setspell_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_setspell(::dapi::commands::SetSpell* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_command();
  if (value) {
    set_has_setspell();
    _impl_.command_.setspell_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dapi.commands.Command.setSpell)
}
inline ::dapi::commands::SetSpell* Command::_internal_mutable_setspell() {
  if (command_case() != kSetSpell) {
    clear_command();
    set_has_setspell();
    _impl_.command_.setspell_ =
        ::google::protobuf::MessageLite::DefaultConstruct<::dapi::commands::SetSpell>(GetArena());
  }
  return _impl_.command_.setspell_;
}
inline ::dapi::commands::SetSpell* Command::mutable_setspell() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dapi::commands::SetSpell* _msg = _internal_mutable_setspell();
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.setSpell)
  return _msg;
}

// .dapi.commands.CastMonster castMonster = 16;
inline bool Command::has_castmonster() const {
  return command_case() == kCastMonster;
}
inline bool Command::_internal_has_castmonster() const {
  return command_case() == kCastMonster;
}
inline void Command::set_has_castmonster() {
  _impl_._oneof_case_[0] = kCastMonster;
}
inline void Command::clear_castmonster() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (command_case() == kCastMonster) {
    if (GetArena() == nullptr) {
      delete _impl_.command_.castmonster_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      if (_impl_.command_.castmonster_ != nullptr) {
        _impl_.command_.castmonster_->Clear();
      }
    }
    clear_has_command();
  }
}
inline ::dapi::commands::CastMonster* Command::release_castmonster() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.castMonster)
  if (command_case() == kCastMonster) {
    clear_has_command();
    auto* temp = _impl_.command_.castmonster_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.castmonster_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dapi::commands::CastMonster& Command::_internal_castmonster() const {
  return command_case() == kCastMonster ? *_impl_.command_.castmonster_ : reinterpret_cast<::dapi::commands::CastMonster&>(::dapi::commands::_CastMonster_default_instance_);
}
inline const ::dapi::commands::CastMonster& Command::castmonster() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.castMonster)
  return _internal_castmonster();
}
inline ::dapi::commands::CastMonster* Command::unsafe_arena_release_castmonster() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dapi.commands.Command.castMonster)
  if (command_case() == kCastMonster) {
    clear_has_command();
    auto* temp = _impl_.command_.castmonster_;
    _impl_.command_.castmonster_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_castmonster(::dapi::commands::CastMonster* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_command();
  if (value) {
    set_has_castmonster();
    _impl_.command_.castmonster_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dapi.commands.Command.castMonster)
}
inline ::dapi::commands::CastMonster* Command::_internal_mutable_castmonster() {
  if (command_case() != kCastMonster) {
    clear_command();
    set_has_castmonster();
    _impl_.command_.castmonster_ =
        ::google::protobuf::MessageLite::DefaultConstruct<::dapi::commands::CastMonster>(GetArena());
  }
  return _impl_.command_.castmonster_;
}
inline ::dapi::commands::CastMonster* Command::mutable_castmonster() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dapi::commands::CastMonster* _msg = _internal_mutable_castmonster();
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.castMonster)
  return _msg;
}

// .dapi.commands.CastXY castXY = 17;
inline bool Command::has_castxy() const {
  return command_case() == kCastXY;
}
inline bool Command::_internal_has_castxy() const {
  return command_case() == kCastXY;
}
inline void Command::set_has_castxy() {
  _impl_._oneof_case_[0] = kCastXY;
}
inline void Command::clear_castxy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (command_case() == kCastXY) {
    if (GetArena() == nullptr) {
      delete _impl_.command_.castxy_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      if (_impl_.command_.castxy_ != nullptr) {
        _impl_.command_.castxy_->Clear();
      }
    }
    clear_has_command();
  }
}
inline ::dapi::commands::CastXY* Command::release_castxy() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.castXY)
  if (command_case() == kCastXY) {
    clear_has_command();
    auto* temp = _impl_.command_.castxy_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.castxy_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dapi::commands::CastXY& Command::_internal_castxy() const {
  return command_case() == kCastXY ? *_impl_.command_.castxy_ : reinterpret_cast<::dapi::commands::CastXY&>(::dapi::commands::_CastXY_default_instance_);
}
inline const ::dapi::commands::CastXY& Command::castxy() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.castXY)
  return _internal_castxy();
}
inline ::dapi::commands::CastXY* Command::unsafe_arena_release_castxy() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dapi.commands.Command.castXY)
  if (command_case() == kCastXY) {
    clear_has_command();
    auto* temp = _impl_.command_.castxy_;
    _impl_.command_.castxy_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_castxy(::dapi::commands::CastXY* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_command();
  if (value) {
    set_has_castxy();
    _impl_.command_.castxy_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dapi.commands.Command.castXY)
}
inline ::dapi::commands::CastXY* Command::_internal_mutable_castxy() {
  if (command_case() != kCastXY) {
    clear_command();
    set_has_castxy();
    _impl_.command_.castxy_ =
        ::google::protobuf::MessageLite::DefaultConstruct<::dapi::commands::CastXY>(GetArena());
  }
  return _impl_.command_.castxy_;
}
inline ::dapi::commands::CastXY* Command::mutable_castxy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dapi::commands::CastXY* _msg = _internal_mutable_castxy();
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.castXY)
  return _msg;
}

// .dapi.commands.ToggleInventory toggleInventory = 18;
inline bool Command::has_toggleinventory() const {
  return command_case() == kToggleInventory;
}
inline bool Command::_internal_has_toggleinventory() const {
  return command_case() == kToggleInventory;
}
inline void Command::set_has_toggleinventory() {
  _impl_._oneof_case_[0] = kToggleInventory;
}
inline void Command::clear_toggleinventory() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (command_case() == kToggleInventory) {
    if (GetArena() == nullptr) {
      delete _impl_.command_.toggleinventory_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      if (_impl_.command_.toggleinventory_ != nullptr) {
        _impl_.command_.toggleinventory_->Clear();
      }
    }
    clear_has_command();
  }
}
inline ::dapi::commands::ToggleInventory* Command::release_toggleinventory() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.toggleInventory)
  if (command_case() == kToggleInventory) {
    clear_has_command();
    auto* temp = _impl_.command_.toggleinventory_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.toggleinventory_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dapi::commands::ToggleInventory& Command::_internal_toggleinventory() const {
  return command_case() == kToggleInventory ? *_impl_.command_.toggleinventory_ : reinterpret_cast<::dapi::commands::ToggleInventory&>(::dapi::commands::_ToggleInventory_default_instance_);
}
inline const ::dapi::commands::ToggleInventory& Command::toggleinventory() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.toggleInventory)
  return _internal_toggleinventory();
}
inline ::dapi::commands::ToggleInventory* Command::unsafe_arena_release_toggleinventory() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dapi.commands.Command.toggleInventory)
  if (command_case() == kToggleInventory) {
    clear_has_command();
    auto* temp = _impl_.command_.toggleinventory_;
    _impl_.command_.toggleinventory_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_toggleinventory(::dapi::commands::ToggleInventory* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_command();
  if (value) {
    set_has_toggleinventory();
    _impl_.command_.toggleinventory_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dapi.commands.Command.toggleInventory)
}
inline ::dapi::commands::ToggleInventory* Command::_internal_mutable_toggleinventory() {
  if (command_case() != kToggleInventory) {
    clear_command();
    set_has_toggleinventory();
    _impl_.command_.toggleinventory_ =
        ::google::protobuf::MessageLite::DefaultConstruct<::dapi::commands::ToggleInventory>(GetArena());
  }
  return _impl_.command_.toggleinventory_;
}
inline ::dapi::commands::ToggleInventory* Command::mutable_toggleinventory() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dapi::commands::ToggleInventory* _msg = _internal_mutable_toggleinventory();
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.toggleInventory)
  return _msg;
}

// .dapi.commands.PutInCursor putInCursor = 19;
inline bool Command::has_putincursor() const {
  return command_case() == kPutInCursor;
}
inline bool Command::_internal_has_putincursor() const {
  return command_case() == kPutInCursor;
}
inline void Command::set_has_putincursor() {
  _impl_._oneof_case_[0] = kPutInCursor;
}
inline void Command::clear_putincursor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (command_case() == kPutInCursor) {
    if (GetArena() == nullptr) {
      delete _impl_.command_.putincursor_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      if (_impl_.command_.putincursor_ != nullptr) {
        _impl_.command_.putincursor_->Clear();
      }
    }
    clear_has_command();
  }
}
inline ::dapi::commands::PutInCursor* Command::release_putincursor() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.putInCursor)
  if (command_case() == kPutInCursor) {
    clear_has_command();
    auto* temp = _impl_.command_.putincursor_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.putincursor_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dapi::commands::PutInCursor& Command::_internal_putincursor() const {
  return command_case() == kPutInCursor ? *_impl_.command_.putincursor_ : reinterpret_cast<::dapi::commands::PutInCursor&>(::dapi::commands::_PutInCursor_default_instance_);
}
inline const ::dapi::commands::PutInCursor& Command::putincursor() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.putInCursor)
  return _internal_putincursor();
}
inline ::dapi::commands::PutInCursor* Command::unsafe_arena_release_putincursor() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dapi.commands.Command.putInCursor)
  if (command_case() == kPutInCursor) {
    clear_has_command();
    auto* temp = _impl_.command_.putincursor_;
    _impl_.command_.putincursor_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_putincursor(::dapi::commands::PutInCursor* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_command();
  if (value) {
    set_has_putincursor();
    _impl_.command_.putincursor_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dapi.commands.Command.putInCursor)
}
inline ::dapi::commands::PutInCursor* Command::_internal_mutable_putincursor() {
  if (command_case() != kPutInCursor) {
    clear_command();
    set_has_putincursor();
    _impl_.command_.putincursor_ =
        ::google::protobuf::MessageLite::DefaultConstruct<::dapi::commands::PutInCursor>(GetArena());
  }
  return _impl_.command_.putincursor_;
}
inline ::dapi::commands::PutInCursor* Command::mutable_putincursor() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dapi::commands::PutInCursor* _msg = _internal_mutable_putincursor();
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.putInCursor)
  return _msg;
}

// .dapi.commands.PutCursorItem putCursorItem = 20;
inline bool Command::has_putcursoritem() const {
  return command_case() == kPutCursorItem;
}
inline bool Command::_internal_has_putcursoritem() const {
  return command_case() == kPutCursorItem;
}
inline void Command::set_has_putcursoritem() {
  _impl_._oneof_case_[0] = kPutCursorItem;
}
inline void Command::clear_putcursoritem() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (command_case() == kPutCursorItem) {
    if (GetArena() == nullptr) {
      delete _impl_.command_.putcursoritem_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      if (_impl_.command_.putcursoritem_ != nullptr) {
        _impl_.command_.putcursoritem_->Clear();
      }
    }
    clear_has_command();
  }
}
inline ::dapi::commands::PutCursorItem* Command::release_putcursoritem() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.putCursorItem)
  if (command_case() == kPutCursorItem) {
    clear_has_command();
    auto* temp = _impl_.command_.putcursoritem_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.putcursoritem_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dapi::commands::PutCursorItem& Command::_internal_putcursoritem() const {
  return command_case() == kPutCursorItem ? *_impl_.command_.putcursoritem_ : reinterpret_cast<::dapi::commands::PutCursorItem&>(::dapi::commands::_PutCursorItem_default_instance_);
}
inline const ::dapi::commands::PutCursorItem& Command::putcursoritem() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.putCursorItem)
  return _internal_putcursoritem();
}
inline ::dapi::commands::PutCursorItem* Command::unsafe_arena_release_putcursoritem() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dapi.commands.Command.putCursorItem)
  if (command_case() == kPutCursorItem) {
    clear_has_command();
    auto* temp = _impl_.command_.putcursoritem_;
    _impl_.command_.putcursoritem_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_putcursoritem(::dapi::commands::PutCursorItem* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_command();
  if (value) {
    set_has_putcursoritem();
    _impl_.command_.putcursoritem_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dapi.commands.Command.putCursorItem)
}
inline ::dapi::commands::PutCursorItem* Command::_internal_mutable_putcursoritem() {
  if (command_case() != kPutCursorItem) {
    clear_command();
    set_has_putcursoritem();
    _impl_.command_.putcursoritem_ =
        ::google::protobuf::MessageLite::DefaultConstruct<::dapi::commands::PutCursorItem>(GetArena());
  }
  return _impl_.command_.putcursoritem_;
}
inline ::dapi::commands::PutCursorItem* Command::mutable_putcursoritem() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dapi::commands::PutCursorItem* _msg = _internal_mutable_putcursoritem();
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.putCursorItem)
  return _msg;
}

// .dapi.commands.DropCursorItem dropCursorItem = 21;
inline bool Command::has_dropcursoritem() const {
  return command_case() == kDropCursorItem;
}
inline bool Command::_internal_has_dropcursoritem() const {
  return command_case() == kDropCursorItem;
}
inline void Command::set_has_dropcursoritem() {
  _impl_._oneof_case_[0] = kDropCursorItem;
}
inline void Command::clear_dropcursoritem() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (command_case() == kDropCursorItem) {
    if (GetArena() == nullptr) {
      delete _impl_.command_.dropcursoritem_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      if (_impl_.command_.dropcursoritem_ != nullptr) {
        _impl_.command_.dropcursoritem_->Clear();
      }
    }
    clear_has_command();
  }
}
inline ::dapi::commands::DropCursorItem* Command::release_dropcursoritem() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.dropCursorItem)
  if (command_case() == kDropCursorItem) {
    clear_has_command();
    auto* temp = _impl_.command_.dropcursoritem_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.dropcursoritem_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dapi::commands::DropCursorItem& Command::_internal_dropcursoritem() const {
  return command_case() == kDropCursorItem ? *_impl_.command_.dropcursoritem_ : reinterpret_cast<::dapi::commands::DropCursorItem&>(::dapi::commands::_DropCursorItem_default_instance_);
}
inline const ::dapi::commands::DropCursorItem& Command::dropcursoritem() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.dropCursorItem)
  return _internal_dropcursoritem();
}
inline ::dapi::commands::DropCursorItem* Command::unsafe_arena_release_dropcursoritem() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dapi.commands.Command.dropCursorItem)
  if (command_case() == kDropCursorItem) {
    clear_has_command();
    auto* temp = _impl_.command_.dropcursoritem_;
    _impl_.command_.dropcursoritem_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_dropcursoritem(::dapi::commands::DropCursorItem* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_command();
  if (value) {
    set_has_dropcursoritem();
    _impl_.command_.dropcursoritem_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dapi.commands.Command.dropCursorItem)
}
inline ::dapi::commands::DropCursorItem* Command::_internal_mutable_dropcursoritem() {
  if (command_case() != kDropCursorItem) {
    clear_command();
    set_has_dropcursoritem();
    _impl_.command_.dropcursoritem_ =
        ::google::protobuf::MessageLite::DefaultConstruct<::dapi::commands::DropCursorItem>(GetArena());
  }
  return _impl_.command_.dropcursoritem_;
}
inline ::dapi::commands::DropCursorItem* Command::mutable_dropcursoritem() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dapi::commands::DropCursorItem* _msg = _internal_mutable_dropcursoritem();
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.dropCursorItem)
  return _msg;
}

// .dapi.commands.UseItem useItem = 22;
inline bool Command::has_useitem() const {
  return command_case() == kUseItem;
}
inline bool Command::_internal_has_useitem() const {
  return command_case() == kUseItem;
}
inline void Command::set_has_useitem() {
  _impl_._oneof_case_[0] = kUseItem;
}
inline void Command::clear_useitem() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (command_case() == kUseItem) {
    if (GetArena() == nullptr) {
      delete _impl_.command_.useitem_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      if (_impl_.command_.useitem_ != nullptr) {
        _impl_.command_.useitem_->Clear();
      }
    }
    clear_has_command();
  }
}
inline ::dapi::commands::UseItem* Command::release_useitem() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.useItem)
  if (command_case() == kUseItem) {
    clear_has_command();
    auto* temp = _impl_.command_.useitem_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.useitem_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dapi::commands::UseItem& Command::_internal_useitem() const {
  return command_case() == kUseItem ? *_impl_.command_.useitem_ : reinterpret_cast<::dapi::commands::UseItem&>(::dapi::commands::_UseItem_default_instance_);
}
inline const ::dapi::commands::UseItem& Command::useitem() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.useItem)
  return _internal_useitem();
}
inline ::dapi::commands::UseItem* Command::unsafe_arena_release_useitem() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dapi.commands.Command.useItem)
  if (command_case() == kUseItem) {
    clear_has_command();
    auto* temp = _impl_.command_.useitem_;
    _impl_.command_.useitem_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_useitem(::dapi::commands::UseItem* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_command();
  if (value) {
    set_has_useitem();
    _impl_.command_.useitem_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dapi.commands.Command.useItem)
}
inline ::dapi::commands::UseItem* Command::_internal_mutable_useitem() {
  if (command_case() != kUseItem) {
    clear_command();
    set_has_useitem();
    _impl_.command_.useitem_ =
        ::google::protobuf::MessageLite::DefaultConstruct<::dapi::commands::UseItem>(GetArena());
  }
  return _impl_.command_.useitem_;
}
inline ::dapi::commands::UseItem* Command::mutable_useitem() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dapi::commands::UseItem* _msg = _internal_mutable_useitem();
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.useItem)
  return _msg;
}

// .dapi.commands.IdentifyStoreItem identifyStoreItem = 23;
inline bool Command::has_identifystoreitem() const {
  return command_case() == kIdentifyStoreItem;
}
inline bool Command::_internal_has_identifystoreitem() const {
  return command_case() == kIdentifyStoreItem;
}
inline void Command::set_has_identifystoreitem() {
  _impl_._oneof_case_[0] = kIdentifyStoreItem;
}
inline void Command::clear_identifystoreitem() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (command_case() == kIdentifyStoreItem) {
    if (GetArena() == nullptr) {
      delete _impl_.command_.identifystoreitem_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      if (_impl_.command_.identifystoreitem_ != nullptr) {
        _impl_.command_.identifystoreitem_->Clear();
      }
    }
    clear_has_command();
  }
}
inline ::dapi::commands::IdentifyStoreItem* Command::release_identifystoreitem() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.identifyStoreItem)
  if (command_case() == kIdentifyStoreItem) {
    clear_has_command();
    auto* temp = _impl_.command_.identifystoreitem_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.identifystoreitem_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dapi::commands::IdentifyStoreItem& Command::_internal_identifystoreitem() const {
  return command_case() == kIdentifyStoreItem ? *_impl_.command_.identifystoreitem_ : reinterpret_cast<::dapi::commands::IdentifyStoreItem&>(::dapi::commands::_IdentifyStoreItem_default_instance_);
}
inline const ::dapi::commands::IdentifyStoreItem& Command::identifystoreitem() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.identifyStoreItem)
  return _internal_identifystoreitem();
}
inline ::dapi::commands::IdentifyStoreItem* Command::unsafe_arena_release_identifystoreitem() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dapi.commands.Command.identifyStoreItem)
  if (command_case() == kIdentifyStoreItem) {
    clear_has_command();
    auto* temp = _impl_.command_.identifystoreitem_;
    _impl_.command_.identifystoreitem_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_identifystoreitem(::dapi::commands::IdentifyStoreItem* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_command();
  if (value) {
    set_has_identifystoreitem();
    _impl_.command_.identifystoreitem_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dapi.commands.Command.identifyStoreItem)
}
inline ::dapi::commands::IdentifyStoreItem* Command::_internal_mutable_identifystoreitem() {
  if (command_case() != kIdentifyStoreItem) {
    clear_command();
    set_has_identifystoreitem();
    _impl_.command_.identifystoreitem_ =
        ::google::protobuf::MessageLite::DefaultConstruct<::dapi::commands::IdentifyStoreItem>(GetArena());
  }
  return _impl_.command_.identifystoreitem_;
}
inline ::dapi::commands::IdentifyStoreItem* Command::mutable_identifystoreitem() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dapi::commands::IdentifyStoreItem* _msg = _internal_mutable_identifystoreitem();
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.identifyStoreItem)
  return _msg;
}

// .dapi.commands.CancelQText cancelQText = 24;
inline bool Command::has_cancelqtext() const {
  return command_case() == kCancelQText;
}
inline bool Command::_internal_has_cancelqtext() const {
  return command_case() == kCancelQText;
}
inline void Command::set_has_cancelqtext() {
  _impl_._oneof_case_[0] = kCancelQText;
}
inline void Command::clear_cancelqtext() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (command_case() == kCancelQText) {
    if (GetArena() == nullptr) {
      delete _impl_.command_.cancelqtext_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      if (_impl_.command_.cancelqtext_ != nullptr) {
        _impl_.command_.cancelqtext_->Clear();
      }
    }
    clear_has_command();
  }
}
inline ::dapi::commands::CancelQText* Command::release_cancelqtext() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.cancelQText)
  if (command_case() == kCancelQText) {
    clear_has_command();
    auto* temp = _impl_.command_.cancelqtext_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.cancelqtext_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dapi::commands::CancelQText& Command::_internal_cancelqtext() const {
  return command_case() == kCancelQText ? *_impl_.command_.cancelqtext_ : reinterpret_cast<::dapi::commands::CancelQText&>(::dapi::commands::_CancelQText_default_instance_);
}
inline const ::dapi::commands::CancelQText& Command::cancelqtext() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.cancelQText)
  return _internal_cancelqtext();
}
inline ::dapi::commands::CancelQText* Command::unsafe_arena_release_cancelqtext() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dapi.commands.Command.cancelQText)
  if (command_case() == kCancelQText) {
    clear_has_command();
    auto* temp = _impl_.command_.cancelqtext_;
    _impl_.command_.cancelqtext_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_cancelqtext(::dapi::commands::CancelQText* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_command();
  if (value) {
    set_has_cancelqtext();
    _impl_.command_.cancelqtext_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dapi.commands.Command.cancelQText)
}
inline ::dapi::commands::CancelQText* Command::_internal_mutable_cancelqtext() {
  if (command_case() != kCancelQText) {
    clear_command();
    set_has_cancelqtext();
    _impl_.command_.cancelqtext_ =
        ::google::protobuf::MessageLite::DefaultConstruct<::dapi::commands::CancelQText>(GetArena());
  }
  return _impl_.command_.cancelqtext_;
}
inline ::dapi::commands::CancelQText* Command::mutable_cancelqtext() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dapi::commands::CancelQText* _msg = _internal_mutable_cancelqtext();
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.cancelQText)
  return _msg;
}

// .dapi.commands.SetFPS setFPS = 25;
inline bool Command::has_setfps() const {
  return command_case() == kSetFPS;
}
inline bool Command::_internal_has_setfps() const {
  return command_case() == kSetFPS;
}
inline void Command::set_has_setfps() {
  _impl_._oneof_case_[0] = kSetFPS;
}
inline void Command::clear_setfps() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (command_case() == kSetFPS) {
    if (GetArena() == nullptr) {
      delete _impl_.command_.setfps_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      if (_impl_.command_.setfps_ != nullptr) {
        _impl_.command_.setfps_->Clear();
      }
    }
    clear_has_command();
  }
}
inline ::dapi::commands::SetFPS* Command::release_setfps() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.setFPS)
  if (command_case() == kSetFPS) {
    clear_has_command();
    auto* temp = _impl_.command_.setfps_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.setfps_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dapi::commands::SetFPS& Command::_internal_setfps() const {
  return command_case() == kSetFPS ? *_impl_.command_.setfps_ : reinterpret_cast<::dapi::commands::SetFPS&>(::dapi::commands::_SetFPS_default_instance_);
}
inline const ::dapi::commands::SetFPS& Command::setfps() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.setFPS)
  return _internal_setfps();
}
inline ::dapi::commands::SetFPS* Command::unsafe_arena_release_setfps() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dapi.commands.Command.setFPS)
  if (command_case() == kSetFPS) {
    clear_has_command();
    auto* temp = _impl_.command_.setfps_;
    _impl_.command_.setfps_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_setfps(::dapi::commands::SetFPS* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_command();
  if (value) {
    set_has_setfps();
    _impl_.command_.setfps_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dapi.commands.Command.setFPS)
}
inline ::dapi::commands::SetFPS* Command::_internal_mutable_setfps() {
  if (command_case() != kSetFPS) {
    clear_command();
    set_has_setfps();
    _impl_.command_.setfps_ =
        ::google::protobuf::MessageLite::DefaultConstruct<::dapi::commands::SetFPS>(GetArena());
  }
  return _impl_.command_.setfps_;
}
inline ::dapi::commands::SetFPS* Command::mutable_setfps() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dapi::commands::SetFPS* _msg = _internal_mutable_setfps();
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.setFPS)
  return _msg;
}

// .dapi.commands.DisarmTrap disarmTrap = 26;
inline bool Command::has_disarmtrap() const {
  return command_case() == kDisarmTrap;
}
inline bool Command::_internal_has_disarmtrap() const {
  return command_case() == kDisarmTrap;
}
inline void Command::set_has_disarmtrap() {
  _impl_._oneof_case_[0] = kDisarmTrap;
}
inline void Command::clear_disarmtrap() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (command_case() == kDisarmTrap) {
    if (GetArena() == nullptr) {
      delete _impl_.command_.disarmtrap_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      if (_impl_.command_.disarmtrap_ != nullptr) {
        _impl_.command_.disarmtrap_->Clear();
      }
    }
    clear_has_command();
  }
}
inline ::dapi::commands::DisarmTrap* Command::release_disarmtrap() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.disarmTrap)
  if (command_case() == kDisarmTrap) {
    clear_has_command();
    auto* temp = _impl_.command_.disarmtrap_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.disarmtrap_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dapi::commands::DisarmTrap& Command::_internal_disarmtrap() const {
  return command_case() == kDisarmTrap ? *_impl_.command_.disarmtrap_ : reinterpret_cast<::dapi::commands::DisarmTrap&>(::dapi::commands::_DisarmTrap_default_instance_);
}
inline const ::dapi::commands::DisarmTrap& Command::disarmtrap() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.disarmTrap)
  return _internal_disarmtrap();
}
inline ::dapi::commands::DisarmTrap* Command::unsafe_arena_release_disarmtrap() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dapi.commands.Command.disarmTrap)
  if (command_case() == kDisarmTrap) {
    clear_has_command();
    auto* temp = _impl_.command_.disarmtrap_;
    _impl_.command_.disarmtrap_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_disarmtrap(::dapi::commands::DisarmTrap* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_command();
  if (value) {
    set_has_disarmtrap();
    _impl_.command_.disarmtrap_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dapi.commands.Command.disarmTrap)
}
inline ::dapi::commands::DisarmTrap* Command::_internal_mutable_disarmtrap() {
  if (command_case() != kDisarmTrap) {
    clear_command();
    set_has_disarmtrap();
    _impl_.command_.disarmtrap_ =
        ::google::protobuf::MessageLite::DefaultConstruct<::dapi::commands::DisarmTrap>(GetArena());
  }
  return _impl_.command_.disarmtrap_;
}
inline ::dapi::commands::DisarmTrap* Command::mutable_disarmtrap() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dapi::commands::DisarmTrap* _msg = _internal_mutable_disarmtrap();
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.disarmTrap)
  return _msg;
}

// .dapi.commands.SkillRepair skillRepair = 27;
inline bool Command::has_skillrepair() const {
  return command_case() == kSkillRepair;
}
inline bool Command::_internal_has_skillrepair() const {
  return command_case() == kSkillRepair;
}
inline void Command::set_has_skillrepair() {
  _impl_._oneof_case_[0] = kSkillRepair;
}
inline void Command::clear_skillrepair() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (command_case() == kSkillRepair) {
    if (GetArena() == nullptr) {
      delete _impl_.command_.skillrepair_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      if (_impl_.command_.skillrepair_ != nullptr) {
        _impl_.command_.skillrepair_->Clear();
      }
    }
    clear_has_command();
  }
}
inline ::dapi::commands::SkillRepair* Command::release_skillrepair() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.skillRepair)
  if (command_case() == kSkillRepair) {
    clear_has_command();
    auto* temp = _impl_.command_.skillrepair_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.skillrepair_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dapi::commands::SkillRepair& Command::_internal_skillrepair() const {
  return command_case() == kSkillRepair ? *_impl_.command_.skillrepair_ : reinterpret_cast<::dapi::commands::SkillRepair&>(::dapi::commands::_SkillRepair_default_instance_);
}
inline const ::dapi::commands::SkillRepair& Command::skillrepair() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.skillRepair)
  return _internal_skillrepair();
}
inline ::dapi::commands::SkillRepair* Command::unsafe_arena_release_skillrepair() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dapi.commands.Command.skillRepair)
  if (command_case() == kSkillRepair) {
    clear_has_command();
    auto* temp = _impl_.command_.skillrepair_;
    _impl_.command_.skillrepair_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_skillrepair(::dapi::commands::SkillRepair* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_command();
  if (value) {
    set_has_skillrepair();
    _impl_.command_.skillrepair_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dapi.commands.Command.skillRepair)
}
inline ::dapi::commands::SkillRepair* Command::_internal_mutable_skillrepair() {
  if (command_case() != kSkillRepair) {
    clear_command();
    set_has_skillrepair();
    _impl_.command_.skillrepair_ =
        ::google::protobuf::MessageLite::DefaultConstruct<::dapi::commands::SkillRepair>(GetArena());
  }
  return _impl_.command_.skillrepair_;
}
inline ::dapi::commands::SkillRepair* Command::mutable_skillrepair() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dapi::commands::SkillRepair* _msg = _internal_mutable_skillrepair();
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.skillRepair)
  return _msg;
}

// .dapi.commands.SkillRecharge skillRecharge = 28;
inline bool Command::has_skillrecharge() const {
  return command_case() == kSkillRecharge;
}
inline bool Command::_internal_has_skillrecharge() const {
  return command_case() == kSkillRecharge;
}
inline void Command::set_has_skillrecharge() {
  _impl_._oneof_case_[0] = kSkillRecharge;
}
inline void Command::clear_skillrecharge() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (command_case() == kSkillRecharge) {
    if (GetArena() == nullptr) {
      delete _impl_.command_.skillrecharge_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      if (_impl_.command_.skillrecharge_ != nullptr) {
        _impl_.command_.skillrecharge_->Clear();
      }
    }
    clear_has_command();
  }
}
inline ::dapi::commands::SkillRecharge* Command::release_skillrecharge() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.skillRecharge)
  if (command_case() == kSkillRecharge) {
    clear_has_command();
    auto* temp = _impl_.command_.skillrecharge_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.skillrecharge_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dapi::commands::SkillRecharge& Command::_internal_skillrecharge() const {
  return command_case() == kSkillRecharge ? *_impl_.command_.skillrecharge_ : reinterpret_cast<::dapi::commands::SkillRecharge&>(::dapi::commands::_SkillRecharge_default_instance_);
}
inline const ::dapi::commands::SkillRecharge& Command::skillrecharge() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.skillRecharge)
  return _internal_skillrecharge();
}
inline ::dapi::commands::SkillRecharge* Command::unsafe_arena_release_skillrecharge() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dapi.commands.Command.skillRecharge)
  if (command_case() == kSkillRecharge) {
    clear_has_command();
    auto* temp = _impl_.command_.skillrecharge_;
    _impl_.command_.skillrecharge_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_skillrecharge(::dapi::commands::SkillRecharge* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_command();
  if (value) {
    set_has_skillrecharge();
    _impl_.command_.skillrecharge_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dapi.commands.Command.skillRecharge)
}
inline ::dapi::commands::SkillRecharge* Command::_internal_mutable_skillrecharge() {
  if (command_case() != kSkillRecharge) {
    clear_command();
    set_has_skillrecharge();
    _impl_.command_.skillrecharge_ =
        ::google::protobuf::MessageLite::DefaultConstruct<::dapi::commands::SkillRecharge>(GetArena());
  }
  return _impl_.command_.skillrecharge_;
}
inline ::dapi::commands::SkillRecharge* Command::mutable_skillrecharge() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dapi::commands::SkillRecharge* _msg = _internal_mutable_skillrecharge();
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.skillRecharge)
  return _msg;
}

// .dapi.commands.ToggleMenu toggleMenu = 29;
inline bool Command::has_togglemenu() const {
  return command_case() == kToggleMenu;
}
inline bool Command::_internal_has_togglemenu() const {
  return command_case() == kToggleMenu;
}
inline void Command::set_has_togglemenu() {
  _impl_._oneof_case_[0] = kToggleMenu;
}
inline void Command::clear_togglemenu() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (command_case() == kToggleMenu) {
    if (GetArena() == nullptr) {
      delete _impl_.command_.togglemenu_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      if (_impl_.command_.togglemenu_ != nullptr) {
        _impl_.command_.togglemenu_->Clear();
      }
    }
    clear_has_command();
  }
}
inline ::dapi::commands::ToggleMenu* Command::release_togglemenu() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.toggleMenu)
  if (command_case() == kToggleMenu) {
    clear_has_command();
    auto* temp = _impl_.command_.togglemenu_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.togglemenu_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dapi::commands::ToggleMenu& Command::_internal_togglemenu() const {
  return command_case() == kToggleMenu ? *_impl_.command_.togglemenu_ : reinterpret_cast<::dapi::commands::ToggleMenu&>(::dapi::commands::_ToggleMenu_default_instance_);
}
inline const ::dapi::commands::ToggleMenu& Command::togglemenu() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.toggleMenu)
  return _internal_togglemenu();
}
inline ::dapi::commands::ToggleMenu* Command::unsafe_arena_release_togglemenu() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dapi.commands.Command.toggleMenu)
  if (command_case() == kToggleMenu) {
    clear_has_command();
    auto* temp = _impl_.command_.togglemenu_;
    _impl_.command_.togglemenu_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_togglemenu(::dapi::commands::ToggleMenu* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_command();
  if (value) {
    set_has_togglemenu();
    _impl_.command_.togglemenu_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dapi.commands.Command.toggleMenu)
}
inline ::dapi::commands::ToggleMenu* Command::_internal_mutable_togglemenu() {
  if (command_case() != kToggleMenu) {
    clear_command();
    set_has_togglemenu();
    _impl_.command_.togglemenu_ =
        ::google::protobuf::MessageLite::DefaultConstruct<::dapi::commands::ToggleMenu>(GetArena());
  }
  return _impl_.command_.togglemenu_;
}
inline ::dapi::commands::ToggleMenu* Command::mutable_togglemenu() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dapi::commands::ToggleMenu* _msg = _internal_mutable_togglemenu();
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.toggleMenu)
  return _msg;
}

// .dapi.commands.SaveGame saveGame = 30;
inline bool Command::has_savegame() const {
  return command_case() == kSaveGame;
}
inline bool Command::_internal_has_savegame() const {
  return command_case() == kSaveGame;
}
inline void Command::set_has_savegame() {
  _impl_._oneof_case_[0] = kSaveGame;
}
inline void Command::clear_savegame() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (command_case() == kSaveGame) {
    if (GetArena() == nullptr) {
      delete _impl_.command_.savegame_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      if (_impl_.command_.savegame_ != nullptr) {
        _impl_.command_.savegame_->Clear();
      }
    }
    clear_has_command();
  }
}
inline ::dapi::commands::SaveGame* Command::release_savegame() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.saveGame)
  if (command_case() == kSaveGame) {
    clear_has_command();
    auto* temp = _impl_.command_.savegame_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.savegame_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dapi::commands::SaveGame& Command::_internal_savegame() const {
  return command_case() == kSaveGame ? *_impl_.command_.savegame_ : reinterpret_cast<::dapi::commands::SaveGame&>(::dapi::commands::_SaveGame_default_instance_);
}
inline const ::dapi::commands::SaveGame& Command::savegame() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.saveGame)
  return _internal_savegame();
}
inline ::dapi::commands::SaveGame* Command::unsafe_arena_release_savegame() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dapi.commands.Command.saveGame)
  if (command_case() == kSaveGame) {
    clear_has_command();
    auto* temp = _impl_.command_.savegame_;
    _impl_.command_.savegame_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_savegame(::dapi::commands::SaveGame* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_command();
  if (value) {
    set_has_savegame();
    _impl_.command_.savegame_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dapi.commands.Command.saveGame)
}
inline ::dapi::commands::SaveGame* Command::_internal_mutable_savegame() {
  if (command_case() != kSaveGame) {
    clear_command();
    set_has_savegame();
    _impl_.command_.savegame_ =
        ::google::protobuf::MessageLite::DefaultConstruct<::dapi::commands::SaveGame>(GetArena());
  }
  return _impl_.command_.savegame_;
}
inline ::dapi::commands::SaveGame* Command::mutable_savegame() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dapi::commands::SaveGame* _msg = _internal_mutable_savegame();
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.saveGame)
  return _msg;
}

// .dapi.commands.Quit quit = 31;
inline bool Command::has_quit() const {
  return command_case() == kQuit;
}
inline bool Command::_internal_has_quit() const {
  return command_case() == kQuit;
}
inline void Command::set_has_quit() {
  _impl_._oneof_case_[0] = kQuit;
}
inline void Command::clear_quit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (command_case() == kQuit) {
    if (GetArena() == nullptr) {
      delete _impl_.command_.quit_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      if (_impl_.command_.quit_ != nullptr) {
        _impl_.command_.quit_->Clear();
      }
    }
    clear_has_command();
  }
}
inline ::dapi::commands::Quit* Command::release_quit() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.quit)
  if (command_case() == kQuit) {
    clear_has_command();
    auto* temp = _impl_.command_.quit_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.quit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dapi::commands::Quit& Command::_internal_quit() const {
  return command_case() == kQuit ? *_impl_.command_.quit_ : reinterpret_cast<::dapi::commands::Quit&>(::dapi::commands::_Quit_default_instance_);
}
inline const ::dapi::commands::Quit& Command::quit() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.quit)
  return _internal_quit();
}
inline ::dapi::commands::Quit* Command::unsafe_arena_release_quit() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dapi.commands.Command.quit)
  if (command_case() == kQuit) {
    clear_has_command();
    auto* temp = _impl_.command_.quit_;
    _impl_.command_.quit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_quit(::dapi::commands::Quit* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_command();
  if (value) {
    set_has_quit();
    _impl_.command_.quit_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dapi.commands.Command.quit)
}
inline ::dapi::commands::Quit* Command::_internal_mutable_quit() {
  if (command_case() != kQuit) {
    clear_command();
    set_has_quit();
    _impl_.command_.quit_ =
        ::google::protobuf::MessageLite::DefaultConstruct<::dapi::commands::Quit>(GetArena());
  }
  return _impl_.command_.quit_;
}
inline ::dapi::commands::Quit* Command::mutable_quit() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dapi::commands::Quit* _msg = _internal_mutable_quit();
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.quit)
  return _msg;
}

// .dapi.commands.ClearCursor clearCursor = 32;
inline bool Command::has_clearcursor() const {
  return command_case() == kClearCursor;
}
inline bool Command::_internal_has_clearcursor() const {
  return command_case() == kClearCursor;
}
inline void Command::set_has_clearcursor() {
  _impl_._oneof_case_[0] = kClearCursor;
}
inline void Command::clear_clearcursor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (command_case() == kClearCursor) {
    if (GetArena() == nullptr) {
      delete _impl_.command_.clearcursor_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      if (_impl_.command_.clearcursor_ != nullptr) {
        _impl_.command_.clearcursor_->Clear();
      }
    }
    clear_has_command();
  }
}
inline ::dapi::commands::ClearCursor* Command::release_clearcursor() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.clearCursor)
  if (command_case() == kClearCursor) {
    clear_has_command();
    auto* temp = _impl_.command_.clearcursor_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.clearcursor_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dapi::commands::ClearCursor& Command::_internal_clearcursor() const {
  return command_case() == kClearCursor ? *_impl_.command_.clearcursor_ : reinterpret_cast<::dapi::commands::ClearCursor&>(::dapi::commands::_ClearCursor_default_instance_);
}
inline const ::dapi::commands::ClearCursor& Command::clearcursor() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.clearCursor)
  return _internal_clearcursor();
}
inline ::dapi::commands::ClearCursor* Command::unsafe_arena_release_clearcursor() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dapi.commands.Command.clearCursor)
  if (command_case() == kClearCursor) {
    clear_has_command();
    auto* temp = _impl_.command_.clearcursor_;
    _impl_.command_.clearcursor_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_clearcursor(::dapi::commands::ClearCursor* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_command();
  if (value) {
    set_has_clearcursor();
    _impl_.command_.clearcursor_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dapi.commands.Command.clearCursor)
}
inline ::dapi::commands::ClearCursor* Command::_internal_mutable_clearcursor() {
  if (command_case() != kClearCursor) {
    clear_command();
    set_has_clearcursor();
    _impl_.command_.clearcursor_ =
        ::google::protobuf::MessageLite::DefaultConstruct<::dapi::commands::ClearCursor>(GetArena());
  }
  return _impl_.command_.clearcursor_;
}
inline ::dapi::commands::ClearCursor* Command::mutable_clearcursor() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dapi::commands::ClearCursor* _msg = _internal_mutable_clearcursor();
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.clearCursor)
  return _msg;
}

// .dapi.commands.IdentifyItem identifyItem = 33;
inline bool Command::has_identifyitem() const {
  return command_case() == kIdentifyItem;
}
inline bool Command::_internal_has_identifyitem() const {
  return command_case() == kIdentifyItem;
}
inline void Command::set_has_identifyitem() {
  _impl_._oneof_case_[0] = kIdentifyItem;
}
inline void Command::clear_identifyitem() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (command_case() == kIdentifyItem) {
    if (GetArena() == nullptr) {
      delete _impl_.command_.identifyitem_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      if (_impl_.command_.identifyitem_ != nullptr) {
        _impl_.command_.identifyitem_->Clear();
      }
    }
    clear_has_command();
  }
}
inline ::dapi::commands::IdentifyItem* Command::release_identifyitem() {
  // @@protoc_insertion_point(field_release:dapi.commands.Command.identifyItem)
  if (command_case() == kIdentifyItem) {
    clear_has_command();
    auto* temp = _impl_.command_.identifyitem_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.identifyitem_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dapi::commands::IdentifyItem& Command::_internal_identifyitem() const {
  return command_case() == kIdentifyItem ? *_impl_.command_.identifyitem_ : reinterpret_cast<::dapi::commands::IdentifyItem&>(::dapi::commands::_IdentifyItem_default_instance_);
}
inline const ::dapi::commands::IdentifyItem& Command::identifyitem() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:dapi.commands.Command.identifyItem)
  return _internal_identifyitem();
}
inline ::dapi::commands::IdentifyItem* Command::unsafe_arena_release_identifyitem() {
  // @@protoc_insertion_point(field_unsafe_arena_release:dapi.commands.Command.identifyItem)
  if (command_case() == kIdentifyItem) {
    clear_has_command();
    auto* temp = _impl_.command_.identifyitem_;
    _impl_.command_.identifyitem_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Command::unsafe_arena_set_allocated_identifyitem(::dapi::commands::IdentifyItem* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_command();
  if (value) {
    set_has_identifyitem();
    _impl_.command_.identifyitem_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dapi.commands.Command.identifyItem)
}
inline ::dapi::commands::IdentifyItem* Command::_internal_mutable_identifyitem() {
  if (command_case() != kIdentifyItem) {
    clear_command();
    set_has_identifyitem();
    _impl_.command_.identifyitem_ =
        ::google::protobuf::MessageLite::DefaultConstruct<::dapi::commands::IdentifyItem>(GetArena());
  }
  return _impl_.command_.identifyitem_;
}
inline ::dapi::commands::IdentifyItem* Command::mutable_identifyitem() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::dapi::commands::IdentifyItem* _msg = _internal_mutable_identifyitem();
  // @@protoc_insertion_point(field_mutable:dapi.commands.Command.identifyItem)
  return _msg;
}

inline bool Command::has_command() const {
  return command_case() != COMMAND_NOT_SET;
}
inline void Command::clear_has_command() {
  _impl_._oneof_case_[0] = COMMAND_NOT_SET;
}
inline Command::CommandCase Command::command_case() const {
  return Command::CommandCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace commands
}  // namespace dapi


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // command_2eproto_2epb_2eh
